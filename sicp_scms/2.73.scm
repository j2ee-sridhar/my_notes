(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        (else ((get 'deriv (operator exp)) (operands exp) var))))

(define (operator exp) (car exp))
(define (operands exp) (cdr exp))

(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1)
       (variable? v2)
       (eq? v1 v2)))
(define (=number? exp num)
  (and (number? exp)
       (= exp num)))

(load "/home/leo/Dropbox/notes/sicp_scms/make-table.scm")
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc))

(define (install-sum-deriv)
  (define (deriv-sum items var)
    (reduce make-sum 0 (map (lambda (x) (deriv x var)) items)))
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (append (list '+)
                        (if (sum? a1)
                            (cdr a1)
                            (list a1))
                        (if (sum? a2)
                            (cdr a2)
                            (list a2))))))
  (define (sum? e)
    (and (pair? e)
         (eq? '+ (car e))))

  (define (deriv-product items var)
    (let ((left (car items))
          (right (if (null? (cddr items))
                     (cadr items)
                     (cons '* (cdr (items))))))
      (make-sum (make-product left
                              (deriv right var))
                (make-product (deriv left var)
                              right))))
  (define (make-product m1 m2)
    (cond ((or (=number? m2 0) (=number? m1 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (append (list '*)
                        (if (product? m1)
                            (cddr m1)
                            (list m1))
                        (if (product? m2)
                            (cddr m2)
                            (list m2))))))
  (define (product? e)
    (and (pair? e)
         (eq? '* (car e))))

  (define (exponentiation? e)
    (and (pair? e)
         (eq? '^ (car e))))
  (define (make-exponention m1 m2)
    (cond ((=number? m1 0) 0)
          ((or (=number? m1 1) (=number? m2 0)) 1)
          ((=number? m2 1) m1)
          (else (list '^ m1 m2))))
  (define (deriv-expon items var)
    (let ((u (car items))
          (n (cadr items)))
      (make-product (make-product n (make-exponention u (- n 1)))
                    (deriv u var))))

  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  (put 'deriv '^ deriv-expon))

(install-sum-deriv)
(deriv '(+ 2 x (^ x 2)) 'x)
