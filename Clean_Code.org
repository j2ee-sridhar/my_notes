* Introduction
小节现真章。细微之处的失败，堆积起来，她会将整个大局的魅力毁灭殆尽。

全员产生维护（Total Productive Maintenance），核心在于 5S
1. 组织
   恰当地分类，命名

2. 整齐
   每段代码都该在你希望它所在的地方。否则，应重构了。

3. 清洁
   遗弃的注释代码，或是反映过往或期望的无注释的代码

4. 标准化
   使用一贯的代码风格的实践手段。

5. 纪律
   乐于改进

通晓技艺只有通过，知和行。学习其相关的原则，模式，和知识; 通过切身的执
行而使得这些东西溶入身体的每个角落。
即使学习了踩单车的原理，你仍会在踩的时候摔倒。编码也是一样。

第一部分讲原则，第二部分分析案例，第三部分记录启示。
第二部分是最需要花费精力的，需要分析和理解那些代码，琢磨每次修改的来龙
去脉。否则，就又只是看了本关于写好软件的“感觉不错”的书。

* Clean Code
什么是好代码，坏代码，及如何把坏代码改成好的代码。

1. 坏代码
   这是一个沼泽，找不到出路，只有死气沉沉的代码越来越多。
   这是不能姑息的。贪一时的快，方便，而写下代码，总想着日后再清理。然而，
   *稍后等于永不* 。

2. 混乱的代价
   所有的改动牵一发而动全身。只有对细节了然于心才能再在上面加代码，生产
   力不断下降。加人手却徒增成本。
   坏代码以至混乱的工程的责任离不开程序员。程序员是制订进度，验证需求的
   基点。
   *维护代码的整洁是程序员的职责*
   *如果对代码质量的追求影响了进度，只能说明你缺乏足够的技能与职业态度*

3. 代码感
   识别混乱，看出其中的选择与变化，然后指导制订修改计划。
   代码反映程序员的品味，技能及素养。应当追求工匠，乃至艺术家的境界。

4. 整洁的代码

   - 逻辑直接而难以隐藏缺陷，最小依赖以便维护，分层策略完善错误处理，调
     优性能而不引诱别人修改。好代码只做一件事，并做好。    —— Bjarne

   *专注于一事* 重视易读性，代码应该在字面上说明自己的功用。往往意图混乱，管
   得太多的代码才难以阅读。

   消除重复代码，只做一件事，注重表达力，小规模抽象。

5. 读与写
   编程，90%都在读周边代码。代码越是整洁易读，写得越轻松，越快。

6. 持续改进
   每次check-in时，代码都应该比check-out的时候更整洁。也许只是一个名字，
   一个长函数分解，一个重复消除，一个嵌套if，但项目在越来越好。

* Meaningful Name
** 名副其实
变量，函数，类的名字应该回答了大部分的问题，为什么存在，它们做什么，以
及怎么使用。如果它还需要额外的注释，则它还不算名副其实。

对命名要严肃处理，一旦发现更好的名字，就换掉旧的。

选好的名字可以使让人理解程序的上下文。

** 避免误导
- 缩略形式常常带来误导。
- 不要用只有微小不同的变量名。
- 以相同的方式拼写同样的概念。例如，程序员们很多时候都直接在方法列表里
  选方法。
- 不要把一组的变量命名为xxxList，即使他真的是一个list。

** 做有意义的区分
- 不要只为了编译通过而去修改名字。

- 不要添加数字系列。
  如果名字必须不同，则它们的意思也应该不同才对。

- 废话永远是冗余的。
  如ProductInfo和ProductData，还不如直接Product。variable不应出现在变
  量名中，table不应出现在表名中。想象一下，Customer和CustomerObject。

** 用读得出来的名字
人类擅长记忆单词，并且编程是件社会活动，你需要讨论。

** 使用可搜索的名字
单字母及数字常量不易搜索定位。
名字的长度应当与它的作用域大小相对应。

** 避免编码
把类型和作用域信息编码进名称里只会增加理解的负担。这不容易发音，而且还
容易拼错。

- 成员前缀
  如果你的类和方法足够小，而且其名字足够表达其意义，你将不需要前缀。而且你使用的开发环境应当要能
  把这些变量高亮以便你区分。

- 接口以及实现
  前缀字母I很多时候是多余的。作者表示，不需要让用户知道交给他们的是一
  个接口还是什么东西，宁愿对实现编码--xxxImp，也不对接口编码。

** 避免思维映射
不应当让读者在脑中把你的名称翻译为他们熟知的名称。应尽量使用问题领域或
是解决方案领域的术语。

** 类名
使用名词，不用动词。并且避免Manager, Processor, Data, Info 之类的词。

** 方法名
使用动词或动词短语。需要重载构造方法时，使用具有合适名字的静态工厂方法。
如
=Complex fulcrumPoint = Complex.FormRealNumber(23.0);=

** 对同一概念只使用同一个词，并在项目中保证一致性
例如，避免在不同的类中，存在各种形同get, retrieve, fetch的方法名。这样
的话，你怎么可能记得哪个类应该用哪个方法名。
另外，如果代码库中controller,manager,driver之类的名称同时存在，就会令
人困惑。不同的名称会让人觉得两个对象是不同类型的，也分属不同的类。

** 不用双关语
一堆类里面都有一个叫add的方法,只要它们的参数和返回值的语义相同，这是可以的（上一条的原则）。
但，应当避免对不同的目的使用同一个词。
例如，如果之前的add已经用来表示增加或连接两个现存值来获得新值的方法，
此时就不应当再把add用于表示把值添加到集合中的方法，这类方法名应该另外
叫做insert。

** 使用解决方案领域的术语
只有程序员才会读你的代码，使用名种程序术语，算法名，设计模式名，数学术
语反而会让读者更好的理解代码。使用问题领域的术语只会让人不得要领，甚至
要去参阅项目文档。
如果不能使用程序员之间常用的术语的时候，才使用问题领域的术语。这样他们
至少可以去参考文档之类。

** 添加有意义的上下文
很多时候，名字只有放在特定的环境才有意义。把他们组成一个整合，（例如，
把长地址的各个字段作为一个新的类的成员属性，），让读者了解该名字对应的
上下文，这样也方便你写出更精悍的代码。

* Function
一个函数难于搞懂，往往是因为做得太多，包含了 *太多的抽象层次* ，奇怪的字符
串，各种嵌套，flag标识的if语句等等。重构吧！

** 短小
一，要小;
二，要比这还再小

三个 *简单标准* ，依次严重
- 要眼珠上下扫动
- 要头部移动
- 要滚动屏幕

*** 代码块和缩进
if, else, while 都应该只有一行。这一行大概是一个函数调用语句。
这标准相当严格。但短小的代码块确可以避免一些不留意的错误，如变量名误用。

函数的缩进层级不应该多于一或两层。

** 只做一件事
*函数应当只做一件事，并把这件事做好。*

问题在于如何判断一些事件步骤是不是属于“只做一件事”。

*标准* 可以参考以下：
- 各个步骤都在该函数名下的同一抽象层次上。

- 他们可以用一个简洁的TO起头的句子来组合描述。
  例如，To blabla， we check blabla, and if so we blabla. In either
  case we blabla.

- 能不能再拆出一个函数，而这个函数不仅仅只是重新实现其内容。

- 只做一件事的函数应该无法被合理地切分为多个段落。

写函数其实就是把对应的函数名的概念进一步拆分为一系列的步骤。

** 一个函数一层抽象
混合多层抽象于同一个函数会把 *细节* 和 *基础概念* 混杂在一起，总会让人
纠结，容易犯错。函数在处理 html 之类的高层抽象时，当中就不应该出现诸如
字符串操作之类的语句。

*** 自顶向下读代码
每个函数后面总是跟着其下一抽象层次函数。
表现在To语句中，就是一个To语句，后面总是紧跟着解释其原理的几个To语句。

** switch 语句
switch有变长的趋势。每当出现新类型里，就要增加语句。在一个函数中存在
switch往往表示其他同层次的函数也可能会出现switch。这个时候增加了新类型，
修改switch语句就是一个灾难。

因此，switch仅当出现在以下条件时，才可以被接受：
- 把switch语句埋到底层，例如抽象工厂下，用于创建多态对象，不让任何人看
  到。
- 仅出现一两次。

** 使用描述性的名称
名称要足够清晰地描述函数所做的事情。一个函数越短小，功能越集中，名字就
应当越容易取。
长的描述性的名称好过令人费解的短名，也好过描述性的注释。
选择描述性的名称能帮你整理设计思路。追求好名称最后导致对代码的重构并不
罕见。
名字应该与模块名一致。如，includeSetupPages,includeSuiteSetupPage.

** 函数参数
最好是0个，其次一，再次二，尽量避免三个，没足够理由不用三个以上的参数。

参数并不与函数名处在同一层抽象上，即读者需要注意到 *不特别重要的细节*。
另外，其参数越多， *测试* 的难度将指数级倍增。

输出参数则比输入参数还要难理解。通常在读函数时都会默认流程为输入数据，处理，
返回输出。如果结果还会在输入参数中返回则常常会花费多一倍的时间去理解。

*** 一元函数
通常这对应两种情况：
1) 想针对参数问一个问题，如 =boolean fileExists("MyFile")=
2) 想对参数进行某个处理，转换，再返回，如 =InputStream fileOpen("MyFile")=

这就是读者所期待的内容。

你的函数名应当能清晰地区分这两种情况，并且总是一致地使用这种命名风格。

另一种应用情况是， *事件*. 这种情况下，只有输入没输出。程序把函数调用
作为一个事件，并通过参数来改变系统的状态。你的函数名应当能够让读者清晰
认识到这个一个事件。

尽量不要把单参数函数应用到除了这三种以外的情况。

**** 标识性(flag)参数
毋宁在上一抽象层级使用if来做判断，或者根据一个全局谱事记录的状态来做出
不同的响应，也不要使用flag参数。

*flag参数一出现，就表明这个函数做了不止一件事*

特别是在读到函数调用的时候很不好理解，如 =render(true)=，只能鼠标移上
去，显示出函数头才好一点。

*** 二元函数
首先其阅读性比单参数要差，另外在调用时容易出错，有多少人在调用
=assertEquals(expected, actual)= 时把参数搞反了的。

应当尽量利用一些机制将其转换为一元函数，例如将其中一个参数改为类成员，
或是把函数改为其中一个参数的成员方法，又或者将输入参数们封装成一个新类。

*** 三元函数
人们常常会忽略比较不重要的参数从而方便理解函数的逻辑。但实际时，我们不
应该忽略任何参数，BUG往往就出在忽略的代码当中。

三个参数会出现更多排序，琢磨，忽略的问题。

*** 参数对象
如果一个函数需要两个，三个或以上的参数，就说明其中一些参数应该要封装为
类了。

*** 动词与关键字
函数取的名字要能较好地解释函数的意图，以及参数的顺序和意思。
例如，
write(name) => writeFiled(name)
assertEqual => assertExpectedEqualActual(expected, actual)

** 无副作用
函数应当只做一件事，而有副作用的函数表明了，它还偷偷地做了其他事。这是
破坏性的，会导致古怪的 *时序性耦合及顺序依赖* 。时序性的耦合限制了函数的使
用时机，在错误的时候调用会造成错误的操作。将时序无关的操作与有关的操作
混杂在一起，无关的操作也变得有关了。

例如，在检查密码正确时的函数中还多余地初始化了会话，从而该函数只能在会话
未开始前调用，否则会丢失已有的会话。

如果一定要时序性耦合，那么就应该在函数名中说明，如
=checkPasswordAndInitializeSession=

** 分隔指令与询问
函数要么执行一个操作，要么回答一个问题，而不应当混杂。

** 使用异常替代返回错误码
这违反了上一条的分隔原则。它鼓励了在if语句判断中把指令当作表达式来使用，
  if (deletePage(page) == E_OK)

调用这种函数则你必须 *立刻* 处理错误，而如果是使用异常，你则可以把错误的处
理逻辑与主逻辑代码 *分离* 出来。
  try {
    xxx
    xxx
  } catch (Exception e) {
    xxx
  }

*** 抽离 try/catch 代码块
这种代码块是很丑陋则影响阅读的。最好是把它们与代码块的主体分离开，另外
形成函数。

#+BEGIN_SRC java
  public void delete (Page page) {
      try {
          deletePageAndAllReferences(page);
      } catch (Exception e) {
          logError(e);
      }
  }

  private void deletePageAndAllReferences(Page page) throws Exception {
      // xxxxx
  }

  private void logError (Exception e) {
      // xxxx
  }
#+END_SRC

*** 错误处理本身就是一件事
错误处理函数不该做其他事，意味着如果关键字try出现在某个函数中，则它应
该是该函数的第一个单词。

*** 依赖磁铁
使用错误代码通常表明程序在其他地方有一个类或是枚举定义了所有的错误码。

这种类就是一个依赖磁铁：多个类必须导入和使用它，当它修改时，所有的其他
类都要重新编译的部署

使用异常，则可以从异常类中派生出新异常，避免重新编译或部署。

** DRY原则
*重复代码可能是软件中一切邪恶的根源* 。而软件开发领域的所有创新都是在不断
尝试从源代码中消灭重复。

这往往会导致，当算法需要修改时，你必须修改所有出现的地方，容易出错。

** 结构化编程
在长函数中，应当尽量做到， *一个入口，一个出口* --即，只有一个return，循环
中没有break 或continue, 永远没有goto, 单点出发走完全部，从而保持阅读性。

* Comments
如果代码难以理解到需要大量注释的程序，应考虑重写，使之较为清晰。

注释是一种必须的恶 -- *如果你的代码有足够的表达力，就不那么需要注释了*
。

注释的恰当用法是用来弥补我们在用代码表达意图时的失败。你之所以要注释往
往就是因为你写的代码本身不能表达自我。每写一次注释就是一次表达能力上的
失败。

之所以如此地贬低注释，是因为注释有时会（无意）说谎。
代码时常变化，但往往很少人跟着去同步地维护注释。时间越久，注释就离所描
述的代码越远，越错。
注释也是有维护成本的！
不准确的注释比没注释还要坏。代码才是唯一能准确告诉你程序做什么事的来源。

** 注释不能挽救糟糕的代码
带有少量注释的整洁而有表达力的代码，远远比带有大量注释的零碎而复杂的代
码像样得多。

** 用代码来阐述
有时候仅仅是简单地建个函数
#+BEGIN_SRC java
  // check to see if the employee is eligible for full benefits
  if ((employee.flags & HOURLY_FLAG) && (employee.age > 65))

  if (employee.isEligibleForFullBenefits())
#+END_SRC

** 好的注释
首先，真正好的注释是你想办法不去写的注释。

*** 法律信息
如果可能，就应当指向一份标准许可或其他外部文档，而不要全放到注释中。

*** 提供信息的注释

#+BEGIN_SRC java
  // returns an instance of the Responder being tested
  protected abstract Reponder responderInstance();

  // 但这时更好的做法是重命名为 responderBeingTested ，这时注释就根本不用了
  // 下面这个好点

  // format matched kk:mm:ss EEE, MMM dd, yyyy
  Pattern timeMatcher = Pattern.compile("\\d*:\\d*:\\d* \\w*,\\w*\\d*,\\d*");
#+END_SRC

*** 对意图的解释

*** 阐释

#+BEGIN_SRC java
  assertTrue(a.compareTo(a) == 0);        // a==a
  assertTrue(a.compareTo(b) != 0);        // a!=b
  assertTrue(aa.compareTo(b) == -1);      // aa<b
  assertTrue(ab.compareTo(aa) == 1);      // ab>aa
#+END_SRC


*** 警示

*** TODO注释

*** 放大
说明某种看起来不合理的操作是很重要的

*** 公用API中的Javadoc

** 坏的注释

*** 喃喃自语
如果要加注释，那就要确保你写出的注释足够好。不清晰的注释本身就只有作者
本人才会理解，成为一种喃喃自语。别人看到，只能困惑地到处通读了其他很多
的内容，才可能会了解其含意。

*** 多余的注释
如果注释不能比代码提供更多的信息，既没有证明代码的意义，也没有给出代码
的意图或逻辑，那么这些注释就根本是增加读者的阅读成本。

*** 误导性注释
首先，函数头的注释就是上述的多余注释。
其次，该函数在 closed 为true时，不一定总是会立刻返回
#+BEGIN_SRC java
  // Utility method that returns when this.closed is true. Throws an exception if the timeout is reached.
  public synchronized void waitForClose(final long timeoutMillis) throws Exception {
      if (!closed) {
          wait(timeoutMillis);
          if (!closed)
              throw new Exception("MockResponseSender could not be closed");
      }
  }
#+END_SRC

*** 只为循规的注释
例如，每个函数都要有Javadoc，实际上这是很烦的，它们把代码变得散乱，还
可能会误导读者。

*** 日志式注释
何年何月，做了什么更改。拜托，VCS吧

*** 废话注释

*** 能用函数或变量时就别用注释

*** 归属与署名
再次，vcs

*** 注释掉的代码
再再次，vcs

*** HTML 注释
注释直接就变得不好读了。
如果注释要由某工具抽取出来呈现到网页，那么应该由工具负责把注释转为html。

*** 非本地信息
不要在本地注释的上下文环境中给出系统级的信息。因为该信息既不能在本地控
制，又不能确保信息的正确性，不好维护。

*** 信息过多
例如，给出RFC文档编号，而不要粘贴内容。

*** 不确切的注释
注释本身就是为了解释不能自行解释的代码，如果注释自己还要额外解释，就太
悲剧了。

*** 函数头
短函数不需要太多的描述。而选好一个函数名，常常比写函数头注释要好。

*** 非公共代码中的Javadoc

* Format
代码格式很重要。你今天写的功能很可能明天就被改了，但是你的格式却仍会产
生长远的影响。

** 垂直格式
*** 垂直密度
紧密联系的代码应当相互靠近。
例如，如果在声明变量的时候添加过多的注释，把变量间割裂开来，实际上并不
好理解。

*** 垂直距离
对于那些关系密切，放置于同一源文件中的概念，它们之间的区隔应作为对相
互的易懂性有多重要的衡量标准。应避免迫吏读者在源文件和类中跳来跳去。

除非有很好的理由，否则不应当把关系密切的概念放到不同的文件中。实际上，
这也是避免使用 *protected* 变量的理由之一。

- 变量声明
  声明应当尽可能靠近其使用的位置。循环的控制变量应该总是在循环语句中声
  明。

- 实体变量
  放在类顶部。这是所有人都知道的惯例，没有理由用其他风格。
  先声明公有部分，然后才是私有。（ *剪刀原则* ）

- 依赖函数
  若某个函数调用了另外一个，则它们应该放到一起，并且调用者应该在被调用
  者的上面。

- 概念相近
  相关性越强，彼此的距离就应越短。例如，有共同的命名，执行同一基础任务的不同变种。

*** 垂直顺序
展示自顶向下的函数调用依赖顺序，越重要的越前面。读者可以从最前面的几个
函数 *获知要旨，而不至于沉溺到细节中* 。

** 横向格式
代码行应该尽力保持短小，最好小于 *80* 个字符。

*** 横向密度
注意把紧密相关的事物连接到一起，用空格间开相关性弱的。
例如，运算优先级低的可以用空格隔开。

*** 水平对齐
很多时候反而会影响阅读（特别是运用在赋值语句的时候），你容易忽视类型而
直接看变量名，而且自动格式化工具很多时候会把对齐消除掉。

如果列表太长而想改善，应当拆分该类，而不是通过对齐。

*** 缩进
即使方法只有一行，也尽量不要把整个方法写成一行，仍该缩进

*** 空范围
尽量不要使用语句体为空的while 或 for 块，这容易看错。如果无法避免，则
应该把分号写到下一行并加以缩进。

** 团队规则
团队规则大于个人，组内的每个人都该使用。可以将其保存到IDE的代码格式功
能当中。

* Object and Data Structures
*保持变量私有，不让其他人依赖这些变量* ，方便我们在心血来潮的时候对其类型
或实现进行更改。

** 数据抽象
隐藏实据本体并不是简单地在变量之间放上一个函数层。其关键在于抽象。

类不能单纯地用取值器和赋值器把变量推向类外面，类所暴露的内容应该形成一
种抽象接口， *用户可以无需了解数据的实现就操作数据本体* 。

例如，Vehicle类中，获取剩余燃料的方法应该返回百分比，而不是特定单位。

** 类与数据结构的反对称性
很多时候，使用数据结构的代码可以在不改动既有数据结构的前提下添加新的函
数，反过来，则需要改所有的函数来支持新的数据结构;而面向对象的代码则方
便于在不改既有函数的前提下添加新的类，但需要更改所有的类来添加新函数。

当然可以用设计模式，但这也是有代价的。

例如，考虑，多边形的面积计算的代码。

它们都应该被应用到它们各自所擅长的地方，而不是死磕对象。
*所谓万物皆对象，只是一个神话。有时你真的只是想要简单的数据结构及操作
的过程* 。

** Demeter原则
模块不应了解它所操作对象的内部情形。类C的方法f只应该调用以下对象的方法，
- C
- 由f创建的对象
- 作为参数传递给f的对象
- 由C的实体变量持有的对象

即， *只与朋友谈话，不与陌生人谈话* .

*** 链接调用
这种调用通常被认为是肮脏的，当出现问题时，常常不得不把它拆分成多行来判
断问题的根源。

#+BEGIN_SRC java
  final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

  // 应当改为
  Options opts = ctxt.getOptions();
  File scratchDir = opts.getScratchDir();
  final String outputDir = scratchDir.getAbsolutePath();
#+END_SRC
这是违背 /Demeter原则/ 的。对于调用者函数来说，它要懂得如何在一大堆不同对
象间浏览--它所需要了解的东西太多了。

*** 混杂
代码拥有执行操作的函数，同时也有公共变量或是公共访问器及改值器。

这同时也是违反了 *单一职权原则* ，对象既传递数据，又执行操作。

公共的setter和getter会把私有的变量公开化，诱导外部函数以 *面向过程* 的方式
使用这些变量-- *Feature Envy* 。
这种类更难以添加新的函数和数据结构。应当避免创造出这种结构。

*** 隐藏结构
上述的例子并不好直接改，但换个思路， *ctxt作为一个对象，我们应该让它执
行某一个操作，而不是询问它关于内部的结构* 。

例如发现，调用者获取绝对路径只是用于创建指定名字的临时文件，这时，我们
完全可以把这个操作直接交给ctxt自身。这时，ctxt 隐藏了其内部结构，防止
当前函数因浏览它不该知道的对象而违反Demter原则。

** 数据传送对象-- DTO
面向对象中的数据结构。

还有一种 Active Record 的特殊的DTO形式，它们还会有类似save和find这样的
可浏览方法。一般而言，它们是对数据库表或其他数据的 *直接翻译* 。

不幸在于发现有很多开发者往这种数据结构中塞进业务逻辑，导致混杂。

正确的做法是，把Active Record当做数据结构，并创建包含业务逻辑，隐藏内
部数据（可能就是Active Record的实体）的独立对象。

* Error Handling
错误处理很重要，但不要让凌乱的错误处理的代码搞乱了代码的逻辑，而让人验
难以阅读。

** 使用异常而非返回码
使用返回码使得处理错误的逻辑（对应非正常的工作情况）和正常逻辑 *混淆*

而且要得到返回码后，你还得即刻处理（先存起来也不妥当），这个步骤还很容
易忘记。

** 先写Try-Catch-Finally语句
这个语句块天然地为你定义了一个范围，
- try中是事务，随时可能取消执行，但不会回滚。
- catch代码块各程序维持在一种状态

*TDD* 中，即使try中没有完整的逻辑，还是可以先跑起测试。

** 使用Unchecked 异常
使用 *Checked* Exception首先的代价是，它违反了 *开放/闭合原则* 。

如果你的方法抛出Checked Exception，在它的调用链上的所有函数都要声明这
个异常，直到所希望的调用者处理掉它。即低级层次中的修改会导致高层级的方
法签名。

** 为异常添加上下文
应当提供足够的环境说明，以便判断错误发生的地方和原因。如果记录日志，则
消息也应该足够清晰。

** 根据调用者需要定制异常类
异常可以根据，来源或类型等进行分类，但更应注重的是，根据它们是 *如何被捕获的* 。

例如，进行某个处理会抛出一系列的异常，而与其对这些异常使用重复的处理代
码，不如，定义一个 *打包类* ，封装这一操作，并在异常时，改为抛出自己定义的
异常。

实际上，对第三方API打包，你就降低了对它的直接依赖。未来需要改用其他代
码库时，会比较方便。同时也方便人你模拟第三方调用，而进行 *测试* 。

** 区分常规流程
注意异常所对应的是 *不正常* 的工作状态，不要把业务逻辑中的特例处理放在
异常处理中。
对于这种特例，应该创建一个类或配置一个对象来特殊处理，这样client就不用
应付这种异常（特例）行为。

** 不要返回null值
*返回null值就是给自己添加工作量* 。

总是会有地方忘记去检查null的（如果你担心其可能会发生，则这件事必然会发
生）。对于系统深处抛出来的NullPointException总是让人无所适从。

如果你在调用某第三方API可能返回null时，打包一层，返回一个特例对象或是
抛出异常都是比较好的方法

#+BEGIN_SRC java
  List<Employee> employees = getEmployees();
  if (employees != null) {
      for(Employee e : employees) {
          totalPay += e.getPay();
      }
  }

  // 改为

  public List<Employee> getEmployees() {
      if(/*.. there are no employees..*/)
          return Collections.emptyList();  // this is final object.
  }


  List<Employee> employees = getEmployees();
  for(Employee e : employees) {
      totalPay += e.getPay();
  }
#+END_SRC

** 不要传递null值
传递null比返回null更加糟糕。

即使添加语句检查null并抛出异常，或是使用 /assert/ 语句来断言，也仍示解
决问题。最好的方法就是大家都形成一个惯例，不要随意传入null。
* Boundaries
保持软件边界(第三方程序包，系统的其他组件或子系统)整洁的手段和技巧。

** 使用第三方代码
接口的提供者和使用者之间总是有一定的矛盾的，一方追求普适性，另一方则尽
可能针对当前的特定需求。

考虑代码使用了Map存储Sensor对象，但Map并不会可靠地约束其中对象的类型，
=sensors.get(sensorId)= 的语句有时也会让人摸不着头脑，并且map会有clear
等一些对于实际需求来说不合适的操作，即Map<Sensor> *提供了超出所需的功
能* 。

在系统中不受限制地传递Map实体，意味着Map的接口被修改时，许多地方也要改
（不一定是Map，也指代一些第三方库接口）。更好的做法是封装Map的使用，隐
藏类型的处理，只暴露合适的接口，用户根本不必关心如何实现，是否使用了泛
型。

*应当将边界上的接口的使用限制在尽可能小的范围* 。
这样，当边界接口变化时，才不会引起连锁修改。

** 浏览和学习边界
学习第三方代码是困难的，而整合第三方代码也是困难的。同时做这两件事更是
难上加难。这很容易导致的情景是，我们在冗长的DEBUG信息中苦苦寻找，而还
不清楚问题是出在哪一方。遇到百思不得其解的BUG很多时候却发现是第三方代
码里的BUG。

与其直接在我们的工作代码上进行实验和尝试，还不如写一些测试性的代码来探
索理解这些第三方代码。

** 学习性测试不仅仅是免费
学习性测试把你学到的知识转换成了代码。这还帮我们，在第三方程序更新的时
候，重新运行测试，看程序的行为有没有改变，是否仍然符合我们系统的需求。

你总要有一系列与生产代码中调用方式一致的输出测试来确保系统边界的整洁。

** 使用尚不存在的代码
有时所需要的库的API还没有定义好，但我们却要开始开发系统。我们可以根据
自己的需要，定义我们使用的接口，使其在我们控制之下，保持客户代码更可读，
且集中于它该完成的工作。

*策略* + *适配器* 模式

Communication                         <Interface>
  Controller       ---------->        Transmitter
                                 +transmit(frequency, stream)
                                          O
                                          |
                                          |
                              -----------------------------
                              |                            |
                              |                            |                    <future>
                       FakeTransmitter                Transmitter ------->    Transmitter API
                                                        Adapter

** 整洁的边界
很多有趣的事会发生在边界上，改动就是其中之一。有良好的软件设计，无需巨
大的投入和重写就可以进行修改。在使用我们控制不了的代码时，必须加倍小心
保护。

*边界上的代码要能够清晰的分隔系统，并有测试能明确定义功能期望* 。

避免我们的代码过多地了解第三方代码中的特定信息，去依赖你能控制的东西，
而不是那些不能控制的，以免以后受其控制。

广泛地讲，边界不仅存在于你的代码与第三方之间，也在类与类，方法与方法之
间。整洁清晰的代码无疑是整洁代码不可割裂的一部分。

* Unit Test
测试是代码的保证，与其同等重要。坐视测试腐坏，那么代码也会随着腐坏。

** TDD三原则
1) 在编写不能通过的单元测试前，不可编写生产代码
2) 只可编写刚好无法通过的单元测试，不能编译也算不通过
3) 只可编写刚好足以通过当前失败测试的生产代码

通过三原则把编码限制在一个循环中，测试失败->生产编码->通过测试->编失败
测试，并注意保持最简。

测试与生产代码一起编写，两者代码量相当，并使得测试能覆盖所有的生产代码。

** 保持测试整洁
从编写用扣即扔的测试到编写全套自动化单元测试是一大进步。

测试必须随生产代码的演进而修改。测试越脏越缠结，就越难修改越花时间。随
着版本的递进，测试的代价也在上升，成为累人的债务,而代码质量也每况愈下。
*破窗效应*

*测试代码和生产代码一样重要*

只要生产代码持续重构，改进，测试就永远是生产代码的试金石。测试保证了代
码的可扩展，可维护，可复用。有了测试，你才能没有后患地做修改。

** 整洁的测试
整洁的标准就是 *可读性* ，在测试中尤其如此。
明确，简洁，以及足够的表达力。不要混杂抽象（充满干扰测试表达力的细节）。

测试最好遵循 *Build-Operate-Check* 的模式。

*** 面向特定领域的测试语言
如有必要，测试类应该拥有自己的内部方法，函数等元素。这些方法，函数构成
用于测试的内部API。

*** 双重标准
生产代码与测试代码应该区分对待，测试注重可读而不必保持与生产代码一样的
运行效率。

** 单个测试中的断言数量应该最小化
每个断言代表一种可能的执行路径，也体现了只做一件事的原则。

每个测试函数中只测试一个概念

** FIRST
- Fast
  运行足够快以便你乐于随时执行

- Independent
  测试相互独立，没有顺序，从而不会串连错误

- Repeatable
  可在任何环境中重复通过，不留借口

- Self-Validating
  测试应该有布尔值输出，而不应使用手工查看日志，对比文件等方式，从而避
  免主观出错。

- Timely
  单元测试应该在恰好可以通过生产代码之前就编写好。
