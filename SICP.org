* Index
- [[* 构造过程抽象][构造过程抽象]]
  - [[* 程序设计的基本元素][程序设计的基本元素]]
    - [[* 表达式][表达式]]
    - [[* 命名和环境][命名和环境]]
    - [[* 组合式求值][组合式求值]]
    - [[* 复合过程][复合过程]]
    - [[* 过程应用的代换模型][过程应用的代换模型]]
    - [[* 条件表达式和谓词][条件表达式和谓词]]
    - [[* 函数与过程][函数与过程]]
    - [[* 过程作为黑箱抽象][过程作为黑箱抽象]]
      - [[* 过程参数][过程参数]]
      - [[* 块结构][块结构]]
  - [[* 过程与它们所产生的计算][过程与它们所产生的计算]]
    - [[* 线性递归和迭代][线性递归和迭代]]
    - [[* 树形递归][树形递归]]
    - [[* 增长的阶][增长的阶]]
    - [[* 求幂][求幂]]
    - [[* 最大公约数][最大公约数]]
    - [[* 素数检测][素数检测]]
  - [[* 用高阶函数做抽象][用高阶函数做抽象]]
    - [[* 过程作为参数][过程作为参数]]
    - [[* 用lambda构造过程][用lambda构造过程]]
      - [[* 用let创建局部变量][用let创建局部变量]]
    - [[* 过程作为一般性的方法][过程作为一般性的方法]]
      - [[* 通过区间折半寻找方程的根][通过区间折半寻找方程的根]]
      - [[* 找出函数的不动点][找出函数的不动点]]
    - [[* 过程作为返回值][过程作为返回值]]
      - [[* 牛顿法][牛顿法]]
      - [[* 抽象和第一级过程][抽象和第一级过程]]
  - [[* 习题][习题]]
- [[* 构造数据抽象][构造数据抽象]]
  - [[* 数据抽象导引][数据抽象导引]]
    - [[* 实例：有理数的算术运算][实例：有理数的算术运算]]
      - [[* 序对][序对]]
    - [[* 抽象屏障][抽象屏障]]
    - [[* 数据意味着什么][数据意味着什么]]
    - [[* 扩展练习：区间算术][扩展练习：区间算术]]
  - [[* 层次性数据和闭包性质][层次性数据和闭包性质]]
    - [[* 序列的表示][序列的表示]]
      - [[* 表操作][表操作]]
      - [[* 对表的映射][对表的映射]]
    - [[* 层次性结构][层次性结构]]
      - [[* 对树的映射][对树的映射]]
    - [[* 序列作为一种约定的接口][序列作为一种约定的接口]]
      - [[* 序列操作][序列操作]]
      - [[* 嵌套映射][嵌套映射]]
  - [[* 符号数据][符号数据]]
    - [[* 引号][引号]]
    - [[* 实例：符号求导][实例：符号求导]]
      - [[* 对抽象数据的求导程序][对抽象数据的求导程序]]
      - [[* 代数表达式的表示][代数表达式的表示]]
    - [[* 实例：集合的表示][实例：集合的表示]]
      - [[* 集合作为未排序的表][集合作为未排序的表]]
      - [[* 有序表实现][有序表实现]]
      - [[* 二叉树实现][二叉树实现]]
      - [[* 实例：Huffman编码树][实例：Huffman编码树]]
  - [[* 抽象数据的多重表示][抽象数据的多重表示]]
    - [[* 复数的表示][复数的表示]]
    - [[* 带标志的数据][带标志的数据]]
    - [[* 数据导向的程序设计和可加性][数据导向的程序设计和可加性]]
      - [[* 消息传递][消息传递]]
  - [[* 带有通用型操作的系统][带有通用型操作的系统]]
    - [[* 通用型算术运算][通用型算术运算]]
    - [[* 不同类型数据的组合][不同类型数据的组合]]
      - [[* 强制][强制]]
      - [[* 类型的层次结构][类型的层次结构]]
      - [[* 层次结构的不足][层次结构的不足]]
    - [[* 实例：符号代数][实例：符号代数]]
      - [[* 多项式算术][多项式算术]]
      - [[* 项表的表示][项表的表示]]
      - [[* 符号代数中类型的层次结构][符号代数中类型的层次结构]]
      - [[* 扩充练习：有理函数][扩充练习：有理函数]]
  - [[* 习题][习题]]
- [[* Modularity, Objects, and State][Modularity, Objects, and State]]
- [[* Metalinguistic Abstraction][Metalinguistic Abstraction]]
- [[* Computing with Register Machines][Computing with Register Machines]]

* 构造过程抽象

现存的许多威力强大的程序设计技术，都依赖于填平在“被动的"数据和”主动的
“过程之间的传统划分。

** 程序设计的基本元素
一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该
成为一种框架，使我们能够在其中组织自己有关计算过程的思想。这样，当我们
描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认
识组合起来形成更复杂认识的方法方面。

每种强有力的语言都为此提供了三种机制：
- 基本表达形式 :: 用于表示语言所关心的最简单的个体
- 组合的方法 :: 通过它们可以从较简单的东西出发构造出复合的元素
- 抽象的方法 :: 通过它们可以为复合对象命名，并将它们当作单元去操作

数据是一种我们希望去操作的东西，而过程就是有关操作这些数据的规则的描述。
上述三机制的针对对象就是数据和过程。

*** 表达式

组合式形成一个表，用于表示一个过程应用。

*** 命名和环境
程序设计语言需要提供一种通过名字去使用计算对象的方式。我们将名字标记符
称为/变量/，它的/值/也就是它所对应的那个对象。为事物命名是一种最简单的
抽象方法。

构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。

而为了保持这种关联性，解释器必须维护某种存储能力，这种存储被称为/环境/。

*** 组合式求值
1) 求值该组合式的各个子表达式
2) 将作为最左子表达式(运算符)的值的那个过程应用于相应的实际参数。

一般而言，我们应该把递归看做一种处理层次性结构的极强有力的技术。事实
上，”值向上穿行“形式的求值形式是一类更一般的计算过程的一个例子，这种计
算过程称为/树形积累/。

第一个步骤的反复应用总可以把我们带到某处的基本表达式。
- 数的值就是它们把表示的数值
- 内部去处符的值就是能完成相应操作的机器序列。

环境所扮演的角色就是用于确定表达式中的各个符号的意义，为求值过程提供上
下文。

(define x 3) 并不是一个组合式，因为对其求值并不是把deine应用于它的两个
实际参数。这种例外称做/特殊形式/。每个特形式都有其自身的求值规则，各种
不同种类的表达式组成了程序语言的语法形式。

对各种表达式的求值规则可以描述为一个简单的通用规则和一组针对不多的特殊
形式的专门规则。

*** 复合过程
/过程定义/即为复合操作提供名字，从而将这样的操作作为一个单元使用。

=(define (<name> <formal parameters>) <body>)=

*** 过程应用的代换模型
将复合过程应用于实际参数，就是将过程体中的每个形参用相应的实参取代后，
对这一过程体求值。

解释器的实际工作方式并不是用值去代换形式参数，而是使用提供局部环境的方
式。

- 正则序求值 :: 完全展开而后归约。先直接替换而不求值，等到真正使用到该
     值的时候再计算. 如果该值出现多次，则会造成重复计算。

- 应用序求值 :: 先求值参数而后应用

对于可以通过替换去模拟并能产生出合法值的过程应用，正则序和应用序求值将
产生同样的值。

使用应用序求值可以避免一些求表达式的重复求值。

*** 条件表达式和谓词

#+BEGIN_SRC emacs-lisp
  (cond (<p1> <e1>)
        (<p2> <e2>)
        ...
        (<pn> <en>)
        (else <e>))

  (if <predicate> <consequent> <alternative>)

  (and <e1> ... <en>)

  (or <e1> ... <en>)

  (not <e>)
#+END_SRC
每个表达式<p>是一个/谓词/，即其值会被解释为真或假。

条件表达式的求值为一直对谓词求值，直至某谓词为真，此时返回子句中/序列
表达式<e>/的值，作为整个条件表达式的值。如果没有真，则cond的值就没有定
义。

谓词是指返回真或假的过程，或是能求出真或假的表达式。

and 和 or 都是特殊形式，因为它们的子表达式不一定都求值。

而 not 则是普通过程。

if 的子句都只能是单个表达式，而 cond 的<e>部分可以是一个表达式的序列，
如果对应的<p>确定为真，<e>中的表达式就会顺序求值，并将最后一个表达式的
值作为整个cond的值返回。

*** 函数与过程
数学的函数与过程之间的一个重要差异是， *过程必须是有效可行的* 。函数与
过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事之间的
普遍性差异的一个具体反映，即说明性描述与行动性描述。


#+BEGIN_SRC scheme
  (define (sqrt-iter guess x)
    (if (good-enough? guess x )
        guess
        (sqrt-iter (improve guess x )
                   x)))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.0001))

  (define (square x)
    (* x x))

  (define (average x y)
    (/ (+ x y) 2))

  (define (sqrt x)
    (sqrt-iter 1.0 x))

  (sqrt 0.00001)



  (define (sqrt-iter2 guess x)
      (if (good-enough2? guess (improve guess x))
          (improve guess x)
          (sqrt-iter2 (improve guess x)
                     x)))

  (define (good-enough2? old-guess new-guess)
      (> 0.01
         (/ (abs (- new-guess old-guess))
            old-guess)))


  (define (sqrt2 x)
    (sqrt-iter2 1.0 x))

  (sqrt2 0.0001)


  (define (improve y x)
    (/ (+ (/ x
             (* y y))
          (* 2 y))
       3))

  (sqrt2 27)
#+END_SRC

*** 过程作为黑箱抽象
即过程抽象，一个过程的定义应该能隐藏起一些细节，从而调用者不必去关心实
现，只须作为一个黑箱而接受它。

**** 过程参数
形参与实参的分离确保了，调用者的变量与被调用者的相分离，黑箱的性质。

一个变量的具体名字是什么完全无关于过程的作用，则称为 *约束变量* ，否则，
它就是 *自由* 的。
例如， good-enough? 中，guess x 都是约束变量，而abs, square, <, - 都是
自由变量。

**** 块结构
词法作用域
例如，可以把good-enough？过程放进sqrt的过程定义当中，这样，其他过程也
可以定义它们自己的good-enough?过程。这样做的另一个好处是，由于x在sqrt
的定义当中是受约束的，good-enough?等子过程圴在x的定义域中，则x可以作为
内部定义的自由变量，子过程不再需要传递x。


** 过程与它们所产生的计算
学习一门新的语言，光学会其语法，就像是学象棋，知道了里面各种棋子的走法，
却不知道典型的开局，战术和策略，缺少有关各种棋步的价值（值得定义哪些过
程）的知识，缺少对所走棋步的各种后果（执行一个过程的效果）做出预期的经
验。

*** 线性递归和迭代
注意 *递归过程* 与 *递归计算过程* 有所区别，如下面的例子中，都是递归过程，但其中一
个为线性递归计算过程，另一个为线性迭代计算过程。

#+BEGIN_SRC scheme
  ; 计算阶乘
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))



  (define (factorial-iter index n result)
    (if (> index n)
        result
        (factorial-iter (+ 1 index)
                        n
                        (* result index))))


  (define (factorial2 n)
    (factorial-iter 1 n 1))
#+END_SRC
前者的代换模型是一种先逐步展开而后收缩的形状，在展开的阶段里，这个过程
构造起一个 *推迟计算的操作* 所形成的链条;收缩阶段则表现为这些去处的实
际执行。这种类型的计算过程由一个推迟执行的去处链条刻画，称为一个 *递归
计算过程* 。其乘法链条的长度随着n值线性增长，因此是 *线性递归过程*.

而像后者那样，在计算过程中的每一步所需要保存的轨迹里，都是固定的
index,n,result的当前值，这种其状态可以用固定数目的 *状态变量* 描述的过
程称为 *迭代计算过程* 。

在C,Pascal之类的语言中，递归的过程所消耗的存储量总是与过程调用的数目成
正比，即使它们所描述的计算过程原理上看是迭代的。这些语言需要通过for,
while 等“循环结构”来描述这些迭代过程，而scheme中则没有这一 *缺陷* 。

能够在常量空间中执行由递归过程所描述的迭代计算过程--具有这种我的实称为
*尾递归* 的。


*** 树形递归
以Fibonacci为例，

#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 2))
                 (fib (- n 1))))))


  (define (fib2 n)
    (fib-iter 0 n 0))

  (define (fib-iter index n sum)
    (if (> index n)
        sum
        (fib-iter (+ index 1)
                  n
                  (+ sum index))))
#+END_SRC

虽然在上述的例子中，树形递归计算过程消耗很大，但它在应用于层次结构性的
数据上时，这种过程是一种自然的威力强大的工具。即使是对于数的计算，它也
可能帮助我们理解和设计程序（上述例子基本上就是把序列的定义直接翻译为了
Lisp语言）。

- 给了半美元，四分之一美元，10美分，5美分和1美分的硬币，将1美元换成零
  钱，一共有几种方式

  #+BEGIN_SRC scheme
  (define (count-change amount)
    (cc amount 5))

  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)  ; count as 1 if amount is 0
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount ; ; 任何使用 kinds-of-coins 种硬币的换法数量
                       (- kinds-of-coins 1)) ; 都等于不使用第一种硬币的换法
                   (cc (- amount
                          (first-denomination kinds-of-coins)) ; 及使用第一种硬币的换法的和
                       kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))


  (count-change 100)
  #+END_SRC

*** 增长的阶
*** 求幂

#+BEGIN_SRC scheme
  (define (expt b n)
    (if (= 0 n)
        1
        (* b (expt b (- n 1)))))


  (define (expt2 b n)
  ;  (expt-iter b n 0 1)
    (expt-iter2 b n 1)
    )

  (define (expt-iter b n cur sum)
    (if (= n cur)
        sum
        (expt-iter b
                   n
                   (+ cur 1)
                   (* sum b))))


  (define (expt-iter2 b n result)
    (if (= 0 n)
        result
        (expt-iter2 b (- n 1) (* result b))))


  (expt 3 3)
  (expt2 3 3)
#+END_SRC

*** 最大公约数

#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0) a
        (gcd b (remainder a b))))
#+END_SRC

*** 素数检测
两种方法，第一种最简单就是从2开始一个个判断直至根号n，此方法具有根号n
的增长阶，
另一种则是，利用费马小定理：
 *如果n是一个素数，则对于任意小于n的正整数a有，a的n次方与a模n同余*

     #+BEGIN_SRC scheme
       (define (smallest-divisor n)
         (find-divisor n 2))

       (define (find-divisor n test-divisor)
         (cond ((> (* test-divisor test-divisor) n) n)
               ((divides? test-divisor n) test-divisor)
               (else (find-divisor n (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))

       (define (prime? n)
         (= n (smallest-divisor n)))

       (define (expmod base exp m)
         (cond ((= exp 0) 1)
               ((even? exp)
                (remainder (square (expmod base (/ exp 2) m))
                           m))
               (else
                (remainder (* base (expmod base (- exp 1) m))
                           m))))

       (define (fermat-test n)
         (define (try-it a)
           (= (expmod a n n) a))
         (try-it (+ 1 (random (- n 1)))))

       (define (fast-prime? n times)
         (cond ((= times 0) true)
               ((fermat-test n) (fast-prime? n (- times 1)))
               (else false)))


       (prime? 19)
       (prime? 199)
       (prime? 1999)
       (prime? 19999)

       (fast-prime? 1234567 10)
     #+END_SRC

** 用高阶函数做抽象
*高阶过程* 即能操作过程的过程，可以增强我们建立抽象的能力

*** 过程作为参数
[[*习题][1.29]]
1.30

*** 用lambda构造过程
#(lambda (<formal-parameters>) <body>)#

这样得到的过程，除了不为有关过程提供名字之外，与define创建的过程完全一
样，即仅仅是该过程没有与环境中的任何名字相关联。

  (define (plus4 x) (+ x 4)  <==> (define plus4 (lambda (x) (+ x 4)))

**** 用let创建局部变量

#+BEGIN_SRC scheme
  (let ((<var1> <exp1>)
        (<var2> <exp2>)
        ;...
        (<varn> <expn>))
    <body>)
#+END_SRC

其语义是，将上同部分的名字约束为局部变量的情况下，对body求值作为let的返回值。
故上述表达式等价于

#+BEGIN_SRC scheme
  ((lambda (<var1> ... <varn>)
     <body>)
   <exp1>
   ;...
   <expn>)
#+END_SRC

这样， *解释器就不需要为let局部变量增加任何新的机制，let表达式只是
lambda表达式的语法外衣而已*

- let可以建立局部变量的约束，即限制作用域
- 变量的值是在let之外计算的！

仅在定义内部过程时使用define

*** 过程作为一般性的方法

**** 通过区间折半寻找方程的根
#+BEGIN_SRC scheme
  (define (close-enough? a b)
    (< (abs (- b a)) 0.001))

  (define (search f a b)
    (if (> (* (f a) (f b)) 0)
        (error "wrong range " a b)
        (let ((mid (/ (+ a b) 2.0)))
          (if (close-enough? a b)
              mid
              (if (> (* (f mid) (f a)) 0)
                  (search f mid b)
                  (search f a mid))))))

  (search sin 2.0 4.0)
  (search sin 2.0 3.0)
#+END_SRC

**** 找出函数的不动点
#+BEGIN_SRC scheme
  (define tolerance 0.00001)

  (define (average a b) (/ (+ a b) 2))

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (sqrt x)
    (fixed-point (lambda (y) (average y (/ x y)))
                 1.0))

  (sqrt 4)
  (fixed-point (lambda (y) (+ (sin y) (cos y)))
               0.1)
#+END_SRC

*** 过程作为返回值
平均阻尼
#+BEGIN_SRC scheme
  (define (average-damp f)
    (lambda (x) (average x (f x))))
#+END_SRC

该过程接受一个过程输入，输出另一个过程

将一个计算过程形式化为一个过程，一般来说存在很多种方式，有经验的程序员
知道如何选择过程的形式，使其特别地清晰且容易理解，使该计算过程中有用的
元素能表现为一些相互分离的个体，并可以重新用于其他的应用。

**** 牛顿法
#+BEGIN_SRC scheme
  (define dx 0.00001)
  (define tolerance 0.00001)

  (define (deriv g)
    (lambda (x) (/ (- (g (+ x dx)) (g x))
                   dx)))

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (newton-transform g)
    (lambda (x)
      (- x (/ (g x) ((deriv g) x)))))

  (define (newton-method g guess)
    (fixed-point (newton-transform g) guess))

  (define (sqrt x)
    (newton-method (lambda (y) (- (square y) x))
                   1.0))

  (sqrt 16)
#+END_SRC

**** 抽象和第一级过程
我们可以进一步抽象出找不动点的过程，其可以接受变换过程g作为输入，
#+BEGIN_SRC scheme
  (define (fixed-point-of-transform f g guess)
    (fixed-point (g f) guess))

  (define (sqrt x)
    (fixed-point-of-transform (lambda (y) (/ x y))
                              average-damp
                              1.0))

  (define (sqrt2 x)
    (fixed-point-of-transform (lambda (y) (- (square y) x))
                              newton-transform
                              1.0))
#+END_SRC

*作为编程者，我们应该对这类可能性保持高度敏感，设法从中识别出程序里的*
*基本抽象，基于它们去进一步构造，并推广它们以创建威力更加强大的抽象*

并不是说要尽可能抽象地去写程序，而是根据工作中的情况，去选择合适的抽象
层次，但这种基于抽象去思考确实是最重要的。

一般而言，语言总会对计算元素的使用方式加上某些限制，而带有最少限制的元素被称为
*第一级状态*.
- 可以用变量命名
- 可以提供给过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

Lisp 的过程是完全的第一状态，这给有效实现提出了挑战，但由此所获得的描述能力却是极其惊人的.

** 习题
- 1.3 :: 计算三个数中，较大的两个数的平方和

     #+BEGIN_SRC scheme
       (define (max-square-sum a b c)
         (if (and (<= a b) (<= a c))
             (return (+ (* b b) (* c c)))
           (max-square-sum b c a))
         )

     #+END_SRC

- 1.6 :: 为什么if是一种特殊形式，如果用conf实现一个new-if，其与if本身
     有什么区别？
     #+BEGIN_SRC scheme
       (define (new-if predicate then-clause else-clause)
         (cond (predicate then-clause)
               (else-clause)))
     #+END_SRC

     区别在于，if作为一种特殊形式，其then-clause和else-clause只有一个
     会被求值。而new-if作为一个普通过程，由于解释器进行应用序求值，其
     两个子过程都会被求值。

     例如，下面的例子不是尾递归，因为sqrt-iter的返回值还要作为new-if的
     参数，

     #+BEGIN_SRC scheme
       (define (sqrt-iter guess x )
         (new-if (good-enough? guess x )
                 guess
                 (sqrt-iter (improve guess x ) ; 无论good-enough结果如何，这个函数调用总会被一直执行
                            x)))


       (new-if (display "good") (display "bad"))
       ; 上述调用将会输出 badgood
     #+END_SRC

- 1.10 :: 给出以下过程

     #+BEGIN_SRC scheme
       (define (A x y)
         (cond ((= y 0) 0)
               ((= x 0) (* 2 y))
               ((= y 1) 2)
               (else (A (- x 1)
                        (A x (- y 1))))))


       (A 1 10) ; 2^10

       (A 2 4)  ; 64436

       (A 3 3)  ; 65536
     #+END_SRC
       求 (A 1 10) (A 2 4) (A 3 3)
     及以下过程的数学意义
     (define (f n) (A 0 n))
     (define (f n) (A 1 n))
     (define (f n) (A 2 n))

     2n
     2^n
     (((...(2^2)^2)^2)...) n-1个

- 1.11 :: f(x) 有以下定义,
     如果n<3,那么f(n)=n,
     如果n>=3, f(n)=f(n-1)+2f(n-2)+3f(n-3)

     请写出递归计算过程及迭代两种过程.

     #+BEGIN_SRC scheme
  (define (f n)
    (if (< n 3)
        n
        (+ (f (- n 1))
           (* 2 (f (- n 2)))
           (* 3 (f (- n 3))))))



  (define (f1 n)
    (if (< n 3)
        n
        (f1-iter 1 2 4 3 n)
        ))

  (define (f1-iter n3 n2 n1 n max)

    (if (= n max)
        n1
        (f1-iter n2
                 n1
                 (+ (* 3 n3) (* 2 n2) n1)
                 (+ n 1)
                 max)))


  (f1 1)
  (f1 2)
  (f1 3)
  (f1 4)
  (f1 5)
#+END_SRC

- 1.12 :: 计算出帕斯卡三角形
     1
     1 2 1
     1 3 3 1
     1 4 6 4 1
     ...

     #+BEGIN_SRC scheme
       (define (tri x y)
         (cond ((or (= x y) (= x 1)) 1)
               ((> x y) (error "unvalid input"))
               (else (+ (tri (- x 1) (- y 1))
                        (tri x (- y 1))))
               ))


       (tri 1 1)
       (tri 1 2)(tri 3 5)
     #+END_SRC

- 1.13 :: 证明Fib(n)是最接近

- 1.14 :: 画出有关的树,表示count-change在11美分换成硬币时的计算过程
     且在金额增加时,这一过程的空间和步数是如何增长

     n 为金额, m为币种,则树的最大深度由m取1时的子树决定,(n,1)子树位于m层,并有(1,1)子树位于n+m层,
     空间增长为O(n+m)

     (n,1)的子树的结点数线性递增,而(n,m)的树可以分解为x(n,m-1)个的子树,当币值远小于n时,可把x视作n,
     时间(节点数)增长为O(n^m)

- 1.15 :: 有以下计算sin(x)的过程, 求计算12.15时,p调用了几次,
     过程的时间及空间增长阶是什么
     #+BEGIN_SRC scheme
       (define (cube x) (* x x x))

       (define (p x) (- (* 3 x) (* 4 (cube x))))

       (define (sine angle)
           (if (not (> (abs angle) 0.1))
               angle
               (p (sine (/ angle 3.0)))))
     #+END_SRC

     由于应用序求值, 5次
     空间时间都是O(log n)

- 1.16 :: 使用以下方法计算乘幂,并使用迭代过程
     b^n = (b^2)^(n/2)
     #+BEGIN_SRC scheme
       (define (fast-expt b n)
         (cond ((= n 0) 1)
               ((isDouble? n) (fast-expt-iter n b))
               (else (* b (fast-expt-iter (- n 1) b)))))

       (define (isDouble? n)
         (= (remainder n 2) 0))

       (define (fast-expt-iter n result)
         (if (= n 1)
             result
             (fast-expt-iter (/ n 2) (* result result))))


       (fast-expt 1 0)
       (fast-expt 2 2)
       (fast-expt 2 3)
       (fast-expt 3 3)


       (define (fast-expt2 b n)
         (fast-expt-iter2 b n 1))

       (define (fast-expt-iter2 b n a)
         (cond ((= n 0) a)

               ((isDouble? n)
                (fast-expt-iter2
                 (* b b)
                 (/ n 2)
                 a))

               (else
                (fast-expt-iter2
                 b
                 (- n 1)
                 (* a b)))))
     #+END_SRC

- 1.17 :: 假设没有乘法,只有doulbe 可用于求某整数的两倍,halve用于求一半,使
     用类似以上的方法求出乘积

     #+BEGIN_SRC scheme
       (define (double a)
         (+ a a))

       (define (halve a)
         (/ a 2))

       (define (even? n)
         (= (remainder n 2) 0))


       (define (* a b)
         (iter a b 0))

       (define (iter a b n)
         (cond ((= b 0) n)
               ((even? b) (iter (double a) (halve b) n))
               (else (iter a (- b 1) (+ n a)))))


       (* 1 0)
       (* 1 1)
       (* 0 1)
       (* 2 1)
       (* 2 4)
       (* 3 3)
       (* 3 4)
     #+END_SRC

- 1.19 :: 斐波那契数列的对数计算过程

- 1.20 :: 在应用序及正则序下，（GCD 206 40)求最大公约数分别调用几次
     remainder

     应用序4次,第一次算,但是gcd( 2 0)不算,if判断后就直接返回a,下面不会
     执行;
     正则序18次,
     正则代换后,则第n层的a b两个参数对应的remainder的次数分别为a(n),
     b(n),
     则: a(n) = b(n-1);b(n)=a(n-1)+b(n-1)+1;a(0)=0,b(0)=0
     总共5层,由于每层的if判断进行了计算,再加上最后一层的a是计算了的,所
     以最后的结果是:b(0)+b(1)+b(2)+b(3)+b(4)+a(4)=18

- 1.21 :: smallest-divisor 测试19, 199, 1999

- 1.22 :: 利用下面过程写一个search-for-prime过程来检查给定范围内各个奇
     数的素性。注意每个素数检查所需要的时间，
  1. 10 000 范围内的耗时真的是1 000 的根号10倍吗
  2. 100 000 与 1 000 000 呢？
  3. 时间真的正比于计算所需要的步数吗？
     #+BEGIN_SRC scheme
       (define (smallest-divisor n)
         (find-divisor n 2))

       (define (find-divisor n test-divisor)
         (cond ((> (* test-divisor test-divisor) n) n)
               ((divides? test-divisor n) test-divisor)
               (else (find-divisor n (+ test-divisor 1)))))

       (define (divides? a b)
         (= (remainder b a) 0))

       (define (prime? n)
         (= n (smallest-divisor n)))


       (define (search-for-primes n)
           (let ((start-time (real-time-clock)))
               (continue-primes n 3)
               (- (real-time-clock) start-time)))

       (define (continue-primes n count)
           (cond ((= count 0)
                   (display "are primes."))
                 ((prime? n)
                   (display n)
                   (newline)
                   (continue-primes (next-odd n) (- count 1)))
                 (else
                   (continue-primes (next-odd n) count))))

       (define (next-odd n)
           (if (odd? n)
               (+ 2 n)
               (+ 1 n)))

       (search-for-primes 10000) ; 3
       (search-for-primes 100000); 6
       (search-for-primes 1000000); 10
   #+END_SRC
   倍数不等

- 1.23 :: 改善test-divisor为2,3,5,7,9 看看耗时是不是真的减半
    耗时相比 3->1, 6->2, 10->10

- 1.24 :: 使用费马检测，速度有何变化，log(n) ?
     2, 3, 3

- 1.25 :: 能否把费马检测中expmod的实现改为直接用下面方法

     #+BEGIN_SRC scheme
       (define (expmod base exp m)
         (remainder (fast-expt base exp) m))
     #+END_SRC

     这个方法理论上一样，但实际上在处理大数字时会溢出，而且速度慢

- 1.26 :: 注意 (square x) 和 (* x x) 并不一定等价。当x是个表达式时，该
     表达式会求值两次。

- 1.27 :: 找出费马检测不出的非素数。

- 1.28 :: 不会被欺骗的费马检查

- 1.29 :: 利用辛普森规则计算积分
     #+BEGIN_SRC scheme
       (define (cube x) (* x x x))

       (define (sum term a next b)
         (if (> a b)
             0
             (+ (term a)
                (sum term (next a) next b))))

       (define (inc n) (+ n 1))

       (define (sum-cubes a b)
         (sum cube a inc b))



       (define (simpson-integration f n a b)
         (define (simpson-iter k)
           (* (if (or (= 0 k)
                      (= n k))
                  1
                  (+ 2
                     (* 2 (remainder k 2))))
              (f (+ a (* k (/ (- b a) n))))))

         (* (/ (/ (- b a) n) 3)
            (sum simpson-iter 0 inc n)))

       (simpson-integration cube 100 0 1)

     #+END_SRC

- 1.30 :: 把上述过程中的SUM转换为迭代过程

     #+BEGIN_SRC scheme
       (define (sum term a next b)
         (define (iter k result)
           (if (> k b)
               result
               (iter (next k) (+ result (term k)))))
         (iter a 0))
     #+END_SRC

- 1.31 :: 写出返回给定范围中各点的某个函数值的乘积（Product）过程，并
     使用它计算下面的phi的近似值。
     phi/4=(2*4*4*6*6*8..../3*3*5*5*7...)
     再写出迭代或递归的版本。

     #+BEGIN_SRC scheme
       (define (product f next a b)
         (define (product-iter result n)
           (if (> n b)
               result
               (product-iter (* result (f n)) (next n))))
         (product-iter 1 a))


       (define (test a) a)

       (define (inc-1 a) (+ a 1))

       (product test inc-1 1 5)


       (define (an n)
         (if (= 0 (remainder n 2))
             (/ n (+ n 1))
             (/ (+ n 1) n)))

       (define (factorial n)
         (* 2 (product an inc-1 1 n)))

       (factorial 10000)

     #+END_SRC

- 1.32 :: 抽象product和sum过程的公共部分，建立过程

     #+BEGIN_SRC scheme
       (define (accumulate combiner null-value term a next b)
         (define (accumulate-iter n result)
           (if (> n b)
               result
               (accumulate-iter (next n)
                                (combiner result
                                          (term n)))))
         (accumulate-iter a null-value))



       (define (sum term a next b)
         (accumulate + 0 term a next b))


       (define (product1 term a next b)
         (accumulate * 1 term a next b))
     #+END_SRC

- 1.33 :: 构造更一般的filtered-accumulate,计算
     a到b中所有素数之和
     小于n的所有互素的正整数之乘积

     #+BEGIN_SRC scheme
       (define (filtered-accumulate filter combiner null-value term a next b)
         (define (filtered-iter result n)
           (if (> n b)
               result
               (filtered-iter (if (filter (term n))
                                  (combiner result (term n))
                                  result)
                              (next n))))
         (filtered-iter null-value a))
     #+END_SRC

- 1.35 :: 证明黄金分割率是 x-> 1+1/x的不动点，并计算其值
     #+BEGIN_SRC scheme
       (define golden-ratio
         (fixed-point (lambda (x) (+ 1(/ 1 x)))
                      1.0))
     #+END_SRC

- 1.36 :: 修改fixed-point过程，使其输出计算中产生的近似值序列 (newline) (display)
     然后通过找出x->log(1000)/log(x)的不动点，确定x^2=1000的一个根。并
     比较使用平均阻尼时的计算步数。
     #+BEGIN_SRC scheme
       (define formula
           (lambda (x)
               (/ (log 1000)
                  (log x))))

       (define (average-damp f)
           (lambda (x)
               (average x
                        (f x))))


       (define tolerance 0.000001)

       (define (fixed-point f first-guess)

           (define (close-enough? v1 v2)
               (< (abs (- v1 v2)) tolerance))

           (define (try guess step)
               (display-info guess step)                       ; 每次进入测试时打印一次猜测
               (let ((next (f guess)))
                   (if (close-enough? next guess)
                       (begin                                  ; 如果猜测完成
                           (display-info next (+ 1 step))      ; 记得算上最后一次计算 next 的猜测
                           next)
                       (try next (+ 1 step)))))

           (try first-guess 1))

       (define (display-info guess step)
           (display "Step: ")
           (display step)
           (display " ")

           (display "Guess: ")
           (display guess)
           (newline))
     #+END_SRC

- 1.40 :: x^3+ax^2+bx+c的零点。
     #+BEGIN_SRC scheme
       (define dx 0.00001)
       (define tolerance 0.00001)

       (define (deriv g)
         (lambda (x) (/ (- (g (+ x dx)) (g x))
                        dx)))

       (define (fixed-point f first-guess)
         (define (close-enough? v1 v2)
           (< (abs (- v1 v2)) tolerance))
         (define (try guess)
           (let ((next (f guess)))
             (if (close-enough? guess next)
                 next
                 (try next))))
         (try first-guess))

       (define (newton-transform g)
         (lambda (x)
           (- x (/ (g x) ((deriv g) x)))))

       (define (newton-method g guess)
         (fixed-point (newton-transform g) guess))

       (define (sqrt x)
         (newton-method (lambda (y) (- (square y) x))
                        1.0))

       (define (cube x) (* x x x))

       (define (cubic a b c)
         (newton-method (lambda (x) (+ (cube x) (* a (square x)) (* b x) c))
                        1.0))
       (cubic 3 2 1)
     #+END_SRC

- 1.41 :: 定义double对输入的过程f应用两次，
     (((double (double double)) inc) 5) 返回什么

     #+BEGIN_SRC scheme
       (define (double f)
         (lambda (x) (f(f x))))

       (((double (double double)) 1+) 5)

       ; 是21啊！！， 反复应用f 是平方，而不是简单乘2
     #+END_SRC

- 1.43 :: 定义 repeat 过程，对输入的数值过程f调用n次
     #+BEGIN_SRC scheme
       (define (repeat1 f n)
         (define (iter g k)
           (if (= k n)
               g
               (iter (lambda (x) (f (g x)))
                     (+ k 1))))
         (iter f 1))


       (define (repeat2 f n)
         (if (= 1 n)
             f
             (lambda (x)
               (f ((repeat2 f (- n 1)) x)))))



       ((repeat1 square 2) 5)
     #+END_SRC

- 1.46 :: 迭代改进，写一个iterative-improve 以两个过程为参数，返回一个
     以某一猜测为输入，通过不断改进，直到得到的猜测足够好为至
     #+BEGIN_SRC scheme
       (define (iterative-improve close-enough? improve)
         (lambda (first-guess)
           (define (try guess)
             (let ((next (improve guess)))
               (if (close-enough? guess next)
                   next
                   (try next))))
           (try first-guess)))


       (define tolerance 0.00001)


       (define (fixed-point f first-guess)
         ((iterative-improve (lambda (x y) (< (abs (- x y)) tolerance))
                             f) first-guess))

       (fixed-point cos 1.0)
     #+END_SRC

     



     

* 构造数据抽象
现在到了数学抽象中最关键的一步：让我们忘记这些符号所表示的对象，（数学
家）不应在这里停步，有许多操作可以应用于这些符号，而根本不必考虑它们到
底代表着什么东西。

本章讨论语言所提供的把数据对象组合起来，形成 *复合数据* 的方式。

复合数据可以提升我们在设计程序时所位于的概念层次，提高设计的模块性，增
强语言的表达能力。

将程序中处理数据对象的表示的部分，与处理数据对象的使用的部分相互隔离的
技术非常具有一般性，形成了一种称为 *数据抽象* 的强有力的设计方法学。

** 数据抽象导引
我们的程序在使用数据时，除了完成当前工作所必要的东西之处，不对所用数据
作任何多余的假设。与此同时，一种“具体”数据表示的定义，也应该与过程中的
数据使用方式无关。在我们的系统里，这两部分之间的界面将是一组过程，称为
*选择函数* 和 *构造函数* 。

*** 实例：有理数的算术运算
#+BEGIN_SRC scheme
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))

  (define (equal-rat? x y)
    (= (* (numer x) (numer y))
       (* (denom x) (denom y))))


  (define (print-rat x)
    (newline)
    (display (numer x))
    (display "/")
    (display (denom x)))
#+END_SRC

这样就有了定义在选择和构造过程 numer,denom 和make-rat 基础上的有理数运算.

**** 序对
序对 是通过过程cons,car,cdr实现的最基本的复合数据.从序对构造起来的数据
对象称为 *表结构* .

#+BEGIN_SRC scheme
  (define (make-rat x y) (cons x y))

  (define (numer x) (car x))

  (define (denom x) (cdr x))

  ;; 使用以下方式会使效率更高,但也会造成调试不便 
  (define mark-rat cons)
  (define numer car)
  (define denom cdr)


  ;; 可利用之前定义的公大公约数过程化简
  (define (mark-rat x y)
    (let ((g (gcd x y)))
      (cons (/ x g)
            (/ y g))))
#+END_SRC

*** 抽象屏障
上述的例子中，我们通过构造函数make-rat, 以及选择函数numer,denom
就刻画出了有理数这种复合数据.

一般而言，数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对
这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只
使用它们。每一层暴露出来的接口都对上层形成了一种 *抽象屏障*

通过 *隔离调用与实现，限制依赖性到少数的几个界面* ，我们可以在低层尚未
实现时就直接根据接口设计高层，另外当低层的实现变化时，高层也不需要修改。

*** 数据意味着什么
并不是任意的构造函数及选择函数就可以构成数据抽象，它还必须具有一组
*特定条件* 使得这些过程成为一套合法的表示。

数据事实上可以 *通过过程来表示* ，如
#+BEGIN_SRC scheme
  (define (cons1 x y)
    (lambda (p)
      (cond ((= p 0) x)
            ((= p 1) y)
            (else (error "Wrong argument. Not 0 or 1.")))))

  (define (car1 p) (p 0))
  (define (cdr1 p) (p 1))

  (car (cons 2 3))
#+END_SRC

*** 扩展练习：区间算术
TODO

** 层次性数据和闭包性质
一般来说，如果通过某种组合数据对象的操作组合起数据对象得到的结果本身还
可以通过同样的操作再进行组合，我们称这种操作满足 *闭包性质* 

支持闭包性质可以提升组合功能的威力使我们建立起层次性的结构。然而很多语
言并不提供一性质又或是难以应用，例如C里，虽然结构的元素可以也是结构，
但却要显式得操作指针，而限制性的要求结构的每个域都只能包含预先定义好形
式的元素。

过程本身也满足这性质－－组合式成员本身也可以是组合式

*** 序列的表示
*序列* 一批数据对象的一种有序汇集。

*表* 是最直接的序列实现，每个cons的cdr指向下一个cons（结束处放nil），
而car里则放元素。scheme为方便构造表有提供基本操作list
=(list <a1> <a2> ... <an>)=
等价于
=(cons <a1> (cons <a2> (cons ... (cons <an> nil) ...)))=

此时，car可以看作是取表的第一项的操作，cdr则是选取表中的剩余项形成的子
表的操作。嵌套可以使用caddar之类的过程，其中的a和d分别表示car和cdr操作,但
要注意是倒序并且最多只能有四个

**** 表操作
- list-ref :: 向下cdr，参数为一个表及一个数，返回这个表中的第n个项
     #+BEGIN_SRC scheme
       (define (list-ref1 list n)
         (if (= 0 n)
             (car list)
             (list-ref1 (cdr list) (- n 1))))
     #+END_SRC

- length :: 利用null?基本操作判断长度
     #+BEGIN_SRC scheme
       (define (length1 list)
         (define (iter list count)
           (if (null? (cdr list))
               count
               (iter (cdr list) (+ count 1))))
         (iter list 0))
     #+END_SRC

- append :: 向上cons，以两个表为参数，返回组合成的一个新表
     #+BEGIN_SRC scheme
       (define (append1 list1 list2)
         (if (null? list1)
             list2
             (cons (car list1) (append (cdr list1) list2))))
     #+END_SRC

**** 对表的映射
*map* ，具有一个过程参数和一个表参数的高阶过程，返回将这一过程应用于表中
各个元素得到的结果形成的表

实际上，如果scheme中的map的第一个参数过程接受n个输入，则map也可以接受n
个表的输入。

#+BEGIN_SRC scheme
  (define (map1 f lit)
    (if (null? lit)
        lit
        (cons (f (car lit))
              (map f (cdr lit)))))


  (define (map2 f lit)
    (define (iter new remain)
      (if (null? remain)
          new
          (iter (cons (f (car remain)) new)
                (cdr remain))))
    (iter () lit))

  (define (inc a) (+ a 1))

  (map1 inc ())
#+END_SRC

map是一种重要的过程，不仅因为它代表了一种公共模式，还因为它建立了一种
处理表的高层抽象（抽象屏障），可以使使用者把注意力集中到表变换的实现上，
隐藏递归结构提取元素的细节。

*** 层次性结构
((1 2) 3 4) 可以看作是一种树，(1 2)是子树， 3和4是根结点的子结点
而把(1 2)拿走后，剩余的(3 4)则相当于拿去第一个结点后形成的树。

递归是处理树结构的一种很自然的工具，因为我们常常可以将对于树的操作归结
为对它们的分支的操作，再将这种操作应用于分支的分支。

#+BEGIN_SRC scheme
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))

  (count-leaves (cons 2 (cons 3 (cons 2 3))))
#+END_SRC

**** 对树的映射
map是处理序列的一种强有力的抽象，与此类似，map与递归的结合也可以作为强
有力的抽象来处理树。

#+BEGIN_SRC scheme
  ;; 处理树的第一个子结点，再对剩余结点形成的树处理，最后并合并为树
  (define (scale-tree tree factor)
    (cond ((null? tree) ())
          ((not (pair? tree)) (* tree factor))
          (else (cons (scale-tree (car tree) factor)
                      (scale-tree (cdr tree) factor)))))


  (scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
              10)

  ;; 另一种方案是将树看成子树的序列，并对它使用map
  (define (scale-tree tree factor)
    (if (null? tree)
        ()
        (map (lambda (x)
               (if (pair? x)
                   (scale-tree x factor)
                   (* x factor)))
             tree)))
#+END_SRC

*** 序列作为一种约定的接口
类似于通过高阶过程对处理数据的一些过程模式进行进一步的抽象
*在抽象数据层面上,我们可以通过统一接口,从而进一步抽象出高阶过程并通过
约定的接口衔接.*

考虑以下两个过程,
#+BEGIN_SRC scheme
  ;; 计算树中的奇数叶子的平方和
  (define (sum-odd-square tree)
    (cond ((null? tree) 0)
          ((not (pair? tree))
           (if (odd? tree) (square tree) 0))
          (else (+ (sum-odd-square (car tree))
                   (sum-odd-square (cdr tree))))))


  ;; 构造出所有为偶数且小于n的斐波那契数列的表
  (define (even-fibs n)
    (define (next k)
      (if (> k n)
        
          (let ((f (fib k)))
            (if (even? f)
                (cons f (next (+ k 1)))
                (next (+ k 1))))))
    (next 0))


  (define (fib n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (else (+ (fib (- n 2))
                   (fib (- n 1))))))
#+END_SRC

虽然它们看上去差异很大,但这两个计算的抽象描述却相当相似
| 步骤 | 第一个程序                | 第二个程序                |
|------+---------------------------+---------------------------|
|    1 | 枚举出一棵树的树叶        | 枚举从0到n的整数          |
|    2 | 过滤它们,选出其中的奇数   | 对每个整数计算相应fib     |
|    3 | 对选出的每个数求平方      | 过滤它们,选出偶数         |
|    4 | 用+累积起得到结果,从0开始 | 用cons累积结果,从空表开始 |
|------+---------------------------+---------------------------|

它们都存在一种过程链,区别在于过滤器和映射的位置不一样.

 *产生信号 --> 过滤器 --> 映射 --> 累积器*

但在上面的两个过程中均没有体现出这种信号流结构,清晰性不够.

**** 序列操作
要组织好程序,使其反映出上述的信号流,关键在于要集中注意力步骤之间的
*信号* . 我们可以用表来表示这些信号,并用表操作实现每个步骤的处理.

则上面两个程序可以转换为
#+BEGIN_SRC scheme
  (define (accumulate f init items)
    (if (null? items)
        init
        (f (car items)
           (accumulate f init (cdr items)))))

  (define (filter predicate squence)
    (cond ((null? squence) ())
          ((predicate (car squence))
           (cons (car squence)
                 (filter predicate (cdr squence))))
          (else (filter predicate (cdr squence)))))

  (define (enumerate-tree tree)
    (cond ((null? tree) ())
          ((not (pair? tree)) (list tree))
          (else (append (enumerate-tree (car tree))
                        (enumerate-tree (cdr tree))))))

  (define (enumerate-interval a b)
    (if (> a b)
        ()
        (cons a (enumerate-interval (+ a 1) b))))


  (define (sum-odd-square tree)
    (accumulate +
                0
                (map square
                     (filter odd?
                             (enumerate-tree tree)))))


  (sum-odd-square (list (list 2 3) 2 (list 6 8)))

  (define (even-fibs n)
    (accumulate cons
                ()
                (filter even?
                        (map fib
                             (enumerate-interval 0 n)))))

  (even-fibs 20)
#+END_SRC

将程序表示为 *针对序列的操作* 可以使程序模块化,从面方便组合这些比较独
立的片段.
而另一方面,如果以序列作为所有的统一表示结构,则程序对于数据结构的
*依赖性可以被限定到不多的几个序列操作上*,而通过修改这些操作,我们就可以
在序列的不同表示之间转换,并保持程序整体的设计不变

模块化是控制复杂性的一种威力强大的策略

上述程序里,把片段重新组合,即可产生一个序列中所有奇数的平方的乘积

#+BEGIN_SRC scheme
  (define (product-of-squares-of-odd-elements items)
    (accumulate *
                1
                (map square
                     (filter odd? items))))
#+END_SRC

与Hadoop的MapReduce相似.

**** 嵌套映射
我们可以扩充序列范型,将许多通用嵌套表述的计算也包含进来.

考虑一个过程,对于n,要求返回1<=i<=j<=n,其i+j为素数.

则其可以使用以下过程枚举输入
#+BEGIN_SRC scheme
  (accumulate append
              ()
              (map (lambda (x)
                     (map (lambda (y)
                            (list x y))
                          (enumerate-interval 1 (- x 1))))
                   (enumerate-interval 1 n)))
#+END_SRC

而这类程序里常常需要做映射,并用append做累积,可以独立定义为一个过程
#+BEGIN_SRC scheme
  (define (flatmap proc items)
    (accumulate append () (map proc items)))
#+END_SRC

则程序为
#+BEGIN_SRC scheme
  (define (flatmap proc items)
    (accumulate append () (map proc items)))


  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  (define (prime-sum-pairs n)
    (map (lambda (p)
           (list (cdr p) (cadr p) (+ (cafr p) (cadr p))))
         (filter prime-sum?
                 (flatmap (lambda (i)
                            (map (lambda (j) (list i j))
                                 (enumerate-interval 1 (- i 1))))
                          (enumerate-interval 1 n)))))
#+END_SRC

除了用于枚举这种区间组合,嵌套映射还可以用于很多序列.
例如一个过程,对给定的序对,输出其全排列
#+BEGIN_SRC scheme
  (define (flatmap proc items)
    (accumulate append () (map proc items)))

  (define (remove x items)
    (filter (lambda (p) (not (= x p))) items))

  (define (permutation s)
    (if (null? s)
        (list '())
        (flatmap (lambda (x)
                   (map (lambda (y)
                          (cons x y))
                        (permutation (remove x s))))
                 s)))

  (permutation (list 1 2 3))

  (define (remove x items)
    (cond ((null? items) ())
          ((= x (car items)) (cdr items))
          (else (cons (car items)
                      (remove x (cdr items))))))
#+END_SRC

** 符号数据
目前为止的所有复合数据都是基于数值的，为了扩充语文的表述能力，还可以将
任意符号作为数据引进。

*** 引号
为了处理(a b c d)之类的包含符号的表，而避免其被看作表达式，例如，如果
我们希望构造出表(a b), 不能单纯用(list a b)，因为lisp会去找a和b的值，
而不是用它们本身。此时我们需要 *为数据对象加引号的能力*

引号是很有威力的东西，它使我们可以 *构造起一种能操作其他表达式的表达式*
但它也会损害语言 中根据简单词语做推理的能力，因为它破坏了对等的东西可
以互换的观念。

*可以在表和符号之前加引号 ’ 来表示其应该作为数据对象看待*

这种写法违背了所有复合表达式都应该由括号限定，具有表的形式的普遍性原则，
实际上'a可以看作是(quote a)的简写形式，从而维持了以下原则，
*解释器看到的所有表达式都可以作为数据对象去操作*

从而空表就可以由'()来表示，而不必用nil了。 eq?可以用来比较两个符号

考虑定义memq，对输入的一个符号和一个表，判断符号在不在表里，不在返回假，
否则返回由匹配项开始的子表
#+BEGIN_SRC scheme
  (define (memq str items)
    (cond ((null? items) #f)
          ((eq? str (car items)) items)
          (else (memq str (cdr items)))))

  (memq 'a '(1 2 a 2 3))
#+END_SRC

*** 实例：符号求导
考虑设计一个执行代数表达式的符号求导过程，以一个代数表达式和一个变量为
为输入，回返这个表达式相对于该变量的导数，

**** 对抽象数据的求导程序
先定义一个求导算法，令他在一些抽象对象上操作，如“和”，“乘积”，“变量”

1. dc/dx=0
2. dx/dx=1
3. d(u+v)/dx = du/dx + dv/dx
4. d(uv)/dx = u(dv/dx) + v(du/dx)

3和4具有递归性质，对一个和式的导数，可以先坟出各项的导数，再将它们相加，
而每个项又可以进一步分解。对此我们需要一个表示代数表达式的方式，可以判
断其是否为，和式，变量，常数，乘式，并可以取出对应子项。
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum (make-product (multiplier exp)
                                   (deriv (multiplicand exp) var))
                     (make-product (multiplicand exp)
                                   (deriv (multiplier exp) var))))
          ((exponentiation? exp)
           (let ((u (base exp))
                 (n (exponent exp)))
             (make-product (make-product
                            (make-exponention u
                                              (- n 1))
                            n)
                           (deriv u var))))
          (else (error "unknow expression type -- DERIV" exp))))
#+END_SRC

**** 代数表达式的表示
我们可以直接采用lisp的前缀表达式。

#+BEGIN_SRC scheme
  (define (variable? x) (symbol? x))
  (define (same-variable? v1 v2)
    (and (variable? v1)
         (variable? v2)
         (eq? v1 v2)))

  (define (sum? e)
    (and (pair? e)
         (eq? '+ (car e))))
  (define (addend e)  (cadr e))
  (define (augend e) (caddr e))
  (define (make-sum a1 a2) (list '+ a1 a2))

  (define (product? e)
    (and (pair? e)
         (eq? '* (car e))))
  (define (multiplier e) (cadr e))
  (define (multiplicand e) (caddr e))
  (define (make-product m1 m2) (list '* m1 m2))
#+END_SRC

但上述过程求出的表达式是没化简的。我们可以通过make-sum和make-product来
实现而不必修改deriv主体

#+BEGIN_SRC scheme
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))

  (define (make-product m1 m2)
    (cond ((or (=number? m2 0) (=number? m1 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list '* m1 m2))))

  (define (=number? exp num)
    (and (number? exp)
         (= exp num)))
#+END_SRC

*** 实例：集合的表示
我们可以根据以下操作来定义出集合这种数据，
- union-set :: 两个集合的并集
- intersection-set :: 两个集合的交集
- element-of-set? :: 判断包含元素
- adjoin-set :: 添加元素

具体的实现可以是任意的，只要它们实现的上述几个操作确实地符合集合的要求

**** 集合作为未排序的表
#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (if (null? set) #f
        (or (equal? x (car set))
            (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (intersection-set s1 s2)
    (cond ((or (null? s1) (null? s2)) '())
          ((element-of-set? (car s1) s2)
           (cons (car s1)
                 (intersection-set (cdr s1) s2)))
          (else (intersection-set (cdr s1) s2))))

  (element-of-set? '(a) '(1 2 (a) b))
  (adjoin-set 'a '())
  (intersection-set '(a 2 c) '(1 a 3 2))
#+END_SRC
设计一种表示形式时，一件必须关注的事情就是效率.
上述实现的时空复杂度为O(n^2)

**** 有序表实现
可以在每次插入元素的时候进行排序.
此时,intersection-set操作可以通过以下方式实现
#+BEGIN_SRC scheme
  (define (intersection-set s1 s2)
    (cond ((or (null? s1) (null? s2)) '())
          ((equal? (car s1) (car s2))
           (cons (car s1) (intersection-set (cdr s1) (cdr s2))))
          ((> (car s1) (car s2))
           (intersection-set s1 (cdr s2)))
          (else (intersection-set (cdr s1) s2))))
#+END_SRC

**** 二叉树实现
通过平衡二叉树,可以实现O(logN)复杂度的查找.
我们可以把结点表示为三个元素的表,该结点的值,左子树,右子树,空表表示没子
树.
#+BEGIN_SRC scheme
  (define (element-of-set? x s)
    (cond ((null? s) #f)
          ((equal? x (entry s) ) #t)
          ((< x (entry s)) (element-of-set? x (left-branch s)))
          (else (element-of-set? x (right-branch s)))))

  (element-of-set? '1 '(7 (5 (2 () ()) (6 () ())) (14 (10 ( ())))))

  (define (adjoin-set x s)
    (cond ((null? set) (make-tree x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-tree (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch ste)))
          ((> x (entry set))
           (make-tree (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))
#+END_SRC

上述操作的效率都通过树是平衡的来保证
另外,注意上面将二叉树实现的抽象

**** 实例：Huffman编码树
构造变长编码，要求每个个体的编码都不会是其他编码的开头，我们可以利用
Huffamn树来实现。每个个体具有一个权重，权重越高，层级越高，往左为0往右
为1,则从根到叶子的路径即是编码

#+BEGIN_SRC scheme
  (define (make-leaf symbol weight)
    (list 'leaf symbol weight))
  (define (leaf? object) (eq? 'leaf (car object)))
  (define (symbol-leaf x) (cadr x))
  (define (weight-leaf x) (caddr x))

  (define (make-code-tree left right)
    (list left
          right
          (append (symbols left) (symbols right))
          (+ (weight left) (weight right))))

  (define (left-branch tree) (car tree))
  (define (right-branch tree) (cadr tree))
  (define (symbols tree)
    (if (leaf? tree)
        (list (symbol-leaf tree))
        (caddr tree)))
  (define (weight tree)
    (if (leaf? tree)
        (weight-leaf tree)
        (cadddr tree)))

  (define (decode bits tree)
    (define (decode-iter bits current-branch)
      (if (null? bits)
          '()
          (let ((next-branch
                 (choose-branch (car bits) current-branch)))
            (if (leaf? next-branch)
                (cons (symbol-leaf next-branch)
                      (decode-iter (cdr bits) tree))
                (decode-iter (cdr bits) next-branch)))))
    (decode-iter bits tree))

  (define (choose-branch bit branch)
    (cond ((= bit 0) (left-branch branch))
          ((= bit 1) (right-branch branch))
          (else (error "bad bit -- CHOOSE_BRANCH" bit))))

  (define (adjoin-set x set) ;有序集合
    (cond ((null? set) (list x))
          ((< (weight x) (weight (car set))) (cons x set))
          (else (cons (car set)
                      (adjoin-set x (cdr set))))))
  (define (make-leaf-set pairs)
    (if (null? pairs)
        '()
        (let ((pair (car pairs)))
          (adjoin-set (make-leaf (car pair)
                                 (cadr pair))
                      (make-leaf-set (cdr pairs))))))
#+END_SRC

** 抽象数据的多重表示
数据抽象作为构造系统的一种方法学,可以使一个程序中的大部分描述能力与这
一程序所操作的数据对象的具体表示的选择无关.

对基础表示的屏蔽可以让我们分隔系统,但这种数据抽象还不够强大有力,因为这
里说的数据对象的"基础表示"并不一定总有意义

对于一个数据对象,其 *有用的表示方式有时候会有多种* ,而我们也可能希望我
们的系统可以处理这多种的表示方式.

例如,复数就可以表示为,
1. 直角坐标形式
2. 极坐标形式

而有时候,需求的不确定,团队的规模,模块的分工,也会形成同一数据的不同表示
方式.

为了使数据可以在一个程序的不同部分中采用不同的表示方式,我们需要构造出
*通用型过程* -- 一种可以在不止一种数据表示上操作的过程.这其中所用到的
主要技术是, *让它们在带有/类型标志/的数据对象上工作*,即数据对象本身就
包含着它们应该如何处理的明确信息.

与此相关的还有 *数据导向* 的程序设计,这是一种用于构造采用了通用型操作
的系统有力而且方便的技术.

*** 复数的表示
很自然地,我们可以把一个复数通过有序对来表示.
  z=x+iy (i^2=-1) ==> (x, y)
或
  (模, 幅角)
有时候对于一个直角坐标表示的复数,我们也是需要取其模的大小,反之亦然.对
  于复数的加法,我们可以用直角坐标计算,而对于模大小,则使用极坐标.

与构造有理数系统时类似,我们假定以下两个构造复数的过程产生相等的复数z
=(make-from-real-imag (real-part z) (imag-part z))=
=(make-from-mag-ang (magnitude z) (angle z))=

然后基于以上的过程,我们可以定义出复数的加减乘除法
#+BEGIN_SRC scheme
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
#+END_SRC

现在具体实现各个构造和选择函数的方法有两种,无论是用直角坐标还是极坐标
实现,我们都可以用三角函数反推出不能直接得出的另外两个选择函数.

*** 带标志的数据
数据抽象其实反映了一种 *最小允诺原则* .让后续的操作都基于构造和选择函
数,我们可以把具体的实现尽量地往后拖.

这个原则可以推进到更极端的情况,即使设计完构造和选择函数,我们仍可以同时
使用两种不同的表示形式,维持表示方式的不确定性.但这时,我们需要一方式来
区分两种不同表示的数据.一种简单的方法就是在复数里放入一个 *类型标志*.
借助这个标志来确定应该使用的选择函数的实现.

#+BEGIN_SRC scheme
  (define (attach-tag type-tag contents)
    (cons (type-tag contents)))
  (define (type-tag datum)
    (if (pair? datnum)
        (car datum)
        (error "Bad tagged datum -- TYPE-TAG" datum)))
  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Bad tagged datum -- CONTENTS" datum)))
#+END_SRC

利用以上过程,就可以定义出谓词
#+BEGIN_SRC scheme
  (define (rectangular? z)
    (eq? (type-tag z) 'rectangular))
  (define (polar? z)
    (eq? (type-tag z) 'polar))
#+END_SRC

然后定义出通用的选择函数,
#+BEGIN_SRC scheme
  (define (real-part z)
    (cond ((rectangular? z)
           (real-part-rectangular (contents z)))
          ((polar? z)
           (real-part-polar (contents z)))
          (else (error "Unknow type -- REAL-PART" z))))

  (define (imag-part z)
    (cond ((rectangular? z)
           (imag-part-rectangular (contents z)))
          ((polar? z)
           (imag-part-polar (contents z)))
          (else (error "Unknow type -- IMAG-PART" z))))

  (define (magnitude z)
    (cond ((rectangular? z)
           (magnitude-rectangular (contents z)))
          ((polar? z)
           (magnitude-polar (contents z)))
          (else (error "Unknow type -- MAGNITUDE" z))))

  (define (angle z)
    (cond ((rectangular? z)
           (angle-rectangular (contents z)))
          ((polar? z)
           (angle-polar (contents z)))
          (else (error "Unknow type -- ANGLE" z))))
#+END_SRC

这时,因为之前定义的加减乘除过程都是基于通用的选择函数的,所以都不用变

类比面向对象中的多态--一个类有不同的实现,而上层之所以可以不分具体子类
是什么就直接当作父类来调用,也跟这里类似.只是在Java中,这种通用的逻辑是
在语言层面实现的,调用者使用的对象里已经包含了包属类的信息(类似于这里的
类型标志),于是JVM就可以通过动态绑定知道要调用哪个子类的方法.

*** 数据导向的程序设计和可加性
检查一个数据项的类型，并据此去调用某个适当过程称为 *基于类型的分派*
虽然这种策略可以获得更强的模块性，但它也存在其他的问题
1. 通用型的界面过程(real-part等)必须知道数据所有的实现
2. 必须保证在整个系统里不存在两个名字相同的过程

即，这种实现通用型界面的技术不具有 *可加性* 。每增加一种实现，其接口都
需要修改。

其实在通用过程需要针对多个不同的类型进行处理时，可以细化为以下表。列放
的是所有可能的操作，而横向的则是所有可能的类型
| 接口操作  | Polar           | Rectangular           |
|-----------+-----------------+-----------------------|
| real-part | real-art-polar  | real-part-rectangular |
| imag-part | imag-part-polar | imag-part-rectangular |
| magnitude | magnitude-polar | magnitude-rectangular |
| angle     | angle-polar     | angle-rectangular     |

数据导向的程序设计就是一种使程序能直接利用这种表格工作的设计技术。
我们在之前的例子中,类型的分派是在通用过程中显式判断的。我们可以把这个
通用过程改为，自动地根据操作名和参数类型的组合去查表，动态地调用对应的
过程。这时，新加入的实现即可以直接在表格中添加项目来实现。

现在假设有put和get来处理表格
=(put <op> <type> <item>)=
=(get <type> <item>)=

则之前的直角坐标实现就可以改为以下过程，
#+BEGIN_SRC scheme
  (define (install-rectangular-package)
    ;; internal procefures
    (define (real-part z) (car z))
    (define (imag-part z) (cdr z))
    (define (make-from-real-imag x y) (cons x y))
    ;; ...

    (define (tag x) (attach-tag 'rectangular x))
    (put 'real-part '(rectangular) real-part) ; 这里用表rectangular是以便允许某些带有多个类型的操作
    (put 'imag-part '(rectangular) imag-part)
    (put 'make-from-real-imag 'rectangular ; 而这里不用表是因为每个构造函数总是绑定于某个特定的类型
         (lambda (x y) (tag (make-from-real-imag x y))))
    ;; ...
  'done)
#+END_SRC
注意到real-part等操作跟之前是完全一样的，但是由于是定义为内部过程，因
此不会有重名冲突
复数算术的选择函数可以通过一个通用的“操作”过程访问有关实现的具体函数。
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (error
             "No method for these types -- APPLY-GENERIC"
             (list op type-tags))))))

  (define (real-part z) (apply-generic 'real-part z))
  (defien (imag-part z) (apply-generic 'imag-part z))
  ;;...
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
#+END_SRC

**** 消息传递
还有一种实现策略就是得用 *”智能数据对象“* ，让它们基于操作名完成所需要
的分派工作。即这时，我们需要的就是把每个数据对象（如一个直角坐标表示的
复数）表示为一个过程。这个过程可以读取输入的操作名，然后执行所需操作。
如，
#+BEGIN_SRC scheme
  (define (make-from-real-imag x y)
    (define (dispatch op)
      (cond ((eq? op 'real-part) x)
            ((eq? op 'imag-part) y)
            ((eq? op 'magnitude)
             (sqrt (+ (squars x) (squars y))))
            ((eq? op 'angle) (atan y x))
            (else
             (error "Unknow op -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)

  (define (apply-generic op arg) (arg op))
#+END_SRC
make-from-real-imag产生的是一个内部过程，然后在 apply-generic反转，让
这个过程可以读取操作名(这里的一个缺点是，只允许一个参数的通用过程）。
之前的cons实现也是用了这种方法。

这种风格的程序设计称为 *消息传递* ，数据对象被设想为一个实体，它以“消
息”的方式接收到所需操作的名字。

与前面两种（显示分派及数据导向）设计方法相比，三者的优劣是：
- 显式分派 :: 这种策略在增加新操作时需要使用者避免命名冲突，而且每当增
     加新类型时，所有通用操作都需要做相应的改动，这种策略不具有可加性，
     因此无论是增加新操作还是增加新类型，这种策略都不适合。
- 数据导向 :: 数据导向可以很方便地通过包机制增加新类型和新的通用操作，
     因此无论是增加新类型还是增加新操作，这种策略都很适合。
- 消息传递 :: 消息传递将数据对象和数据对象所需的操作整合在一起，因此它
     可以很方便地增加新类型，但是这种策略不适合增加新操作，因为每次为
     某个数据对象增加新操作之后，这个数据对象已有的实例全部都要重新实
     例化才能使用新操作。

** 带有通用型操作的系统
我们可以把有理数算术，复数算术以及常规算术合并起来，并只对外提供add等
通用操作，使这一系统更具有可加性

*** 通用型算术运算
可以使用类似之前的数据导向的方法去定义通用型的算术过程
#+BEGIN_SRC scheme
  (define (add x y) (apply-generic 'add x y))
  (define (sub x y) (apply-generic 'sub x y))
  (define (mul x y) (apply-generic 'mul x y))
  (define (div x y) (apply-generic 'div x y))

  ;; 安装常规数，每个操作都有两个参数，所以用表(scheme-number scheme-number)
  (define (install-scheme-number-package)
    (define (tag x)
      (attach-tag 'scheme-number x))
    (put 'add '(scheme-number scheme-number)
         (lambda (x y) (tag (+ x y))))
    (put 'sub '(scheme-number scheme-number)
         (lambda (x y) (tag (- x y))))
    (put 'mul '(scheme-number scheme-number)
         (lambda (x y) (tag (* x y))))
    (put 'div '(scheme-number scheme-number)
         (lambda (x y) (tag (/ x y))))
    (put 'make 'scheme-number
         (lambda (x) (tag x)))
    'done)

  (define (make-scheme-number n)
    ((get 'make 'scheme-number) n))


  ;; 安装有理数算术包
  (define (install-retional-package)
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    (define (make-rat n d)
      (let ((g (gcd n d)))
        (cons (/ n g) (/ d g))))
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (- (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (* (numer x) (numer y))
                (* (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (* (numer x) (denom y))
                (* (denom x) (numer y))))

    (define (tag x) (attach-tag 'retional x))
    (put 'add '(rational rational)
         (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
         (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
         (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
         (lambda (x y) (tag (div-rat x y))))

    (put 'make 'rational
         (lambda (n d) (tag (make-rat n d))))
    'done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))  

  (define (install-rectangular-package)
    (define (make-from-real-imag x y)
      ((get 'make-from-real-imag 'rectangular) x y))
    (define (make-from-mag-ang r a)
      ((get 'make-from-mag-ang 'polar) r a))

    ;; internal procefures
    (define (add-complex z1 z2)
      (make-from-real-imag (+ (real-part z1) (real-part z2))
                           (+ (imag-part z1) (imag-part z2))))
    (define (sub-complex z1 z2)
      (make-from-real-imag (- (real-part z1) (real-part z2))
                           (- (imag-part z1) (imag-part z2))))
    (define (mul-complex z1 z2)
      (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                         (+ (angle z1) (angle z2))))
    (define (div-complex z1 z2)
      (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                         (- (angle z1) (angle z2))))

    (define (tag x) (attach-tag 'complex x))
    (put 'add '(complex complex)
         (lambda (x y) (tag (add-complex x y))))
    (put 'sub '(complex complex)
         (lambda (x y) (tag (sub-complex x y))))
    (put 'mul '(complex complex)
         (lambda (x y) (tag (mul-complex x y))))
    (put 'div '(complex complex)
         (lambda (x y) (tag (div-complex x y))))
    (put 'make-from-real-imag 'complex
         (lambda (x y) (tag (make-from-real-imag x y))))
    (put 'make-from-mag-ang 'complex
         (lambda (x y) (tag (make-from-mag-ang x y))))
  'done)

  (define (make-complex-from-real-imag x y)
    ((get 'make-from-real-imag 'complex) x y))
  (define (make-complex-from-mag-ang r a)
    ((get 'make-from-mag-ang 'complex) r a))
#+END_SRC
注意到复数系统具有两层标志 内层rectangular， 外层complex

*** 不同类型数据的组合
在之前的例子中，我们把不同类型的数据看作是完全互相分离的东西，但有时候
我们需要对一个常规数加上一个有理数，即，存在 *需要跨越类型的操作* ,我
们需要可控地去做这件事，在支持这种操作同时避免严重损害模块性。

我们可以针对每种类型组合定义相应的操作（注意，此时标志顺序敏感），然后
安装到表格里。
#+BEGIN_SRC scheme
  (define (add-complex-to-scheme z x)
    (make-from-real-imag (+ (real-part z) x)
                         (imag-part z)))

  (put 'add '(complex scheme-number)
       (lambda (z x) (tag (add-complex-to-scheme z x))))
#+END_SRC

但其缺点也很明显，
1. 组合相当地多，每引入一个新类型，都要构造所有实现跨类型操作的过程
2. 跨类型操作所需要的代码很容易就超过了定义类型本身所需要的那些操作
3. 损害了独立开发模块的能力

**** 强制
如果需要处理针对一批完全无关的类型的一批完全无关的操作，直接实现跨类型
操作也许就是最好的方式，并且我们可以一些技巧做一些简化。

*强制* -- 如果一种类型的对象可以看作是另一个类型的对象，则我们可以定
义一种过程，把一个类型的对象转换到另一类型的等价对象。例如，把常规数看
作是特殊的有理数。但表格有一部分是可能为空的，因为不一定所有的类型组合
操作都有意义。
#+BEGIN_SRC scheme
  (define (scheme-number->complex n)
    (make-complex-from-real-imag (contents n) 0))

  (put-corecion 'scheme-number 'complex scheme-number->complex)
#+END_SRC

存在一种转换过程之后，我们就可以在应用 apply-generic 过程时，自行判断
该类型是否可以转换以便找到适用的操作。
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (let ((t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (consd (t1->t2
                            (apply-generic op (t1->t2 a1) a2))
                           (t2->t1
                            (apply-generic op a1 (t2->t1 a2)))
                           (else
                            (error "No method for these tyeps"
                                   (list op type-tags))))))
                (error "No method for these typesf"
                       (list op type-tags)))))))
#+END_SRC

与显示定义跨类型操作相比，这种利用强制的方式仅需要为每一对类型写一个转
换操作（有需要的话，甚至可以在系统中实现从类型图中寻找出转换链）。这存
在一个提前， *类型间的转换只依赖于类型本身，与实际应用的操作无关*

**** 类型的层次结构
强制模式要求一对类型之间存在某种自然的关系，而实际中，还它们之间常常还
存在着更“全局性”的结构。

例如，在之前的系统中其实存在以下 *类型的层次结构* 
  整数 => 有理数 => 实数 => 复数

*超类型* 和 *子类型* 构成了一个类型树，此时，加入一个新类型就可以简化
为 *刻画该类型如何嵌入它的超类型，以及如何作为下面一个类型的超类型*
然后不同类型间的操作就都可以通过向上转换到相同的超类型来实现。

类型树的另一个优点在于，我们很容易就实现出一种概念：
*每一种类型都可以”继承“其超类型中定义的所有操作*
我们可以把apply-generic改为，当所给类型没有定义对应的操作时，就把这种
类型提升为它的超类型，直至找到定义或者到根报错。

另外，我们也可以在适当时候把一个对象”下降“，使之达到最简形式。如2+3i和
4-3i的加法，其结果可以下降为一个整数6

**** 层次结构的不足
有时候类型的关系不单单是一棵树，而是一个图，即一个类型可能存在多于一个
的超类型。此时不存在一种唯一的方式去提升一个特定的类型。当我们需要将一
个操作应用于一个对象时，为些而找出”正确“的超类型的工作(applyl-generic)
可能就涉及了对整个类型网络的大范围搜索。
处理大型系统时，处理好一大批相互有关的类型的同时又能保持模块性，这是一
个非常困难的问题，也是一直以来的一个研究领域。


*** 实例：符号代数
一般来说，一个代数表达式可以看作是一种层次结构，它是将去运算符作用于一
些运算对象而形成的一棵树

**** 多项式算术
为简单起见，把多项式限制为只有一个未定元的情况，而每个项的系数可以是另
一个未定元的多项式。
如 (y^2+1)x^3 + (2y)x +1 是x的一个多项式，而其参数又是y的多项式。根据
数据抽象的方式开始设计这个系统
#+BEGIN_SRC scheme
  (define (install-polynomial-package)
    ;; internal procedures
    ;; representation of poly
    (define (make-poly variable term-list)
      (cons variable term-list))
    (define (variable p) (car p))
    (define (term-list p) (cdr p))
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1)
           (variable? v2)
           (eq? v1 v2)))
    (define (=number? exp num)
      (and (number? exp)
           (= exp num)))

    ;; representation of terms and term lists
    (define (add-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (add-term (term-list p1)
                               (term-list p2)))
          (error "Polys not in same var -- ADD-POLY"
                 (list p1 p2))))

    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-term (term-list p1)
                               (term-list p2)))
          (error "Polys not in same var -- MUL-POLY"
                 (list p1 p2))))

    ;; interface to rest of the system
    (define (tag p) (attach-tag 'polynomial p))
    (put 'add '(polynomial polynomial)
         (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
         (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
         (lambda (var terms) (tag (make-poly var terms))))
    'done)
#+END_SRC

为了处理表项（加法中需要把同次的项相加），我们还需要其他专门的过程。
#+BEGIN_SRC scheme
  ;; 通过以下操作把项和项表都看成数据抽象
  ;; adjoin-term 把一个新项加入到一个项表里
  ;; the-empty-termlist 返回空表项
  ;; empty-termlist? 检查表项是否为空
  ;; first-term 提取表项中的最高次的项
  ;; rest-terms 返回除最高次项外的其他项表
  ;; order 返回项的次数
  ;; coeff 返回项的系数

  (define (add-terms l1 l2)
    (cond ((empty-termlist? l1) l2)
          ((empty-termlist? l2) l1)
          (else
           (let ((t1 (first-term l1)) (t2 (first-term l2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-term (rest-terms l1) l2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-term l1 (rest-terms l2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (add (coeff t1) (coeff t2)))
                     (add-terms (rest-terms l1)
                                (rest-terms l2)))))))))

  (define (mul-terms l1 l2)
    (if (empty-termlist? l1)
        (the-empty-termlist)
        (add-terms (mul-term-by-all-terms (first-term l1) l2)
                   (mul-terms (rest-terms l1) l2))))

  (define (mul-term-by-all-terms t1 l)
    (if (empty-termlist? l)
        (the-empty-termlist)
        (let ((t2 (first-term l)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-term l))))))
#+END_SRC

由于使用了通用的add和mul过程,如果我们还把之前的强制机制也包括进来,那么
这里也就有了自动处理不同系数类型的多项式的能力.
另外,由于多项式的add-poly和mul-poly安装进通用自算术系统的add和mul操作
里,则得系统还可以处理以多项式为系数的多项式 (需要添加额外的强制--把2x
看作是(2*y^0)x).

**** 项表的表示
最后我们需要为项表实现一种很好的表示形式. 从作用上可以看作是系数的集合.
因此,我们可以用之前介绍的表示集合的方法.
由于add-terms和mul-terms都以顺序的方式进行访问,最好 *采用某种有序表表
示*.

显然,对于稠密的项表而言,(1 2 0 3 -2 -5)之类方法可以很方便地表示--每项
对应的次数为该项开始的子表的长度减一.但如果项表是稀疏的,则这种表示会包
含太多没用的0,此时可以用((100 1) (2 2) (0 1))来表示,子表中的前一项为项
数,后一项为系数
#+BEGIN_SRC scheme
  (define (adjoin-term term term-list)
    (if (=zero? (coeff term)) ; 2-80 
        term-list
        (cons term term-list)))
  ;; 虽然这里是用简单的cons连接项表.但只要所有调用adjoin-term的过程(如add-terms)
  ;; 都保证term的次数大于表中所有项,则项表仍是有序的.

  (define (the-empty-termlist) '())
  (define (first-term term-list) (car term-list))
  (define (rest-terms term-list) (cdr term-list))
  (define (empty-termlist? term-list) (null? term-list))

  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cdr term))

  (define (make-polynomial var terms)
    ((get 'make 'polynomial) var terms))
#+END_SRC

**** 符号代数中类型的层次结构
我们的多项式系统显示出, 一种类型(多项式)的对象事实上可以是一个复杂的对
象,又以许多不同类型的对象作为其组成部分
利用 *通用型操作* 及 *数据导向* 的程序设计风格,我们可以看到多项式形成
一类 *递归数据抽象* , 以较为简单的方式就处理好复杂性.

但另一方面,注意到多项式并 *不能自然地安排到类型塔里* . 因为,一个多项式
中可能混杂了多个变元.例如,有一个以x为变元的多项式(其系数为以y为变元的
多项式),而另一个则刚好相反, 这时需要进行"转换"才能对它们进行相加.

一种可能是,把其中一个多项式强制为另一个多项式
另外就是,定义类型塔,总把多项式变换为以较高优先级的变元表示.

无论哪种,都需要通过展开并重新安排多项式里的项,使其更难读,也可能操作起
来的效率更低.

当用户可以动态地通过已有类型的各种组合形式引进新类型时,类塔策略常常显
得不太合适.

**** 扩充练习：有理函数
TODO
** 习题
- 2.1 :: 写出更好的make-rat过程,使其可以正确处理正负数,负负应显示为正,
     仅一个正时,应显示在分子上.
     [[file:sicp_scms/2.1.scm::(gcd%20b%20(remainder%20a%20b))))][2.1.scm]]

- 2.2 :: 定义坐标，线段，以及返回线段中点的过程。
     [[file:sicp_scms/2.2.scm::(define%20seg%20(make-segment%20start%20end))][2.2.scm]]

- 2.3 :: 定义平面矩形，及周长，面积的过程，对于不同的表示都可以正常计算
     [[file:sicp_scms/2.3.scm][file:~/Dropbox/notes/sicp_scms/2.3.scm]]

- 2.5 :: 把序对表示为2^a*3^b,写出cons，car，cdr
     [[file:sicp_scms/2.5.scm::(cdr2%20(cons2%203%20-5))][2.5.scm]]

- 2.6 :: 邱奇数

- 2.17 :: 请定义出过程last-pair,返回给定非空表里最后一个元素的表
   [[file:sicp_scms/2.17.scm::(last-pair%20(list%2023%2072%20149%2034))][2.17.scm]]

- 2.18 :: 定义过程reverse
     [[file:sicp_scms/2.18.scm::(reverse1%20(list%201%202%203%204%205))][2.18.scm]]

- 2.19 :: 把之前的换零钱的例子改成使用表
     (define us-cons (list 50 25 10 5 1))
     [[file:sicp_scms/2.19.scm][file:~/Dropbox/notes/sicp_scms/2.19.scm]]

- 2.20 :: 过程＋，×和list都可以接受任意个参数，这种过程的定义方法是采
     用一种 *带点尾部标记法* 的形式的define，如
     =(define (f x y . z) <body>)=
     则(f 1 2 3 4 5)时，x是1,y是2,z则是表(3 4 5)

     使用这种形式，定义过程same-parity，以一个或多个整数为参数，返回所
     有与第一个参数有同样奇偶性的参数形成的表
     [[file:sicp_scms/2.20.scm::(same-parity%202%202%203%204%205%206%207)][2.20.scm]]

- 2.22 :: 迭代的map实现是倒序的，为什么？即使交换cons中的参数还是不行，
     为什么？

     递归时，cons总是推迟执行，所以是从最后一个开始组合，与迭代是相反
     的。如果交换cons参数，则表的各个元素的指针不对。
          
- 2.23 :: 过程for-each与map类似，它有一个过程和表参数，但返回的是将这
     一过程从左到右应用于各个元素，并将值都丢掉。用于执行动作的过程，
     如打印。请给出定义
     [[file:sicp_scms/2.23.scm][file:~/Dropbox/notes/sicp_scms/2.23.scm]]

- 2.24 :: 给出下面表的树定义，盒子图
     =(list 1 (list 2 (list 3 4)))=

- 2.25 :: 给出能够取出7的car和cdr组合
     (1 3 (5 7) 9)
     ((7))
     (1 (2 (3 (4 (5 (6 7))))))

     =(car (cdr (car (cdr (cdr items)))))=
     =(car (cdaddr items))=
     
     =(car (car items))=

     =(cadadr (cadadr (cadadr items)))=

- 2.26 :: 猜测下面过程的结果
     =(define x (list 1 2 3))=
     =(define y (list 4 5 6))=
     =(append x y)=
     =(cons x y)=
     =(list x y)=
     
     (1 2 3 4 5 6)
     ((1 2 3) 4 5 6)
     ((1 2 3) (4 5 6))

- 2.27 :: 定义deep-reverse过程，把表中的元素反转，其子树也反转。
    [[file:sicp_scms/2.27.scm::(iter%20(cons%20(if%20(pair?%20(car%20remain))][2.27.scm]]

- 2.28 :: 实现fringe过程，以一个树为参数，返回一个表，表中的元素是这棵
     树的所有叶子，按照从左到右的顺序，如
     =(define x (list (list 1 2) (list 3 4)))=
     (fringe x) ==> (1 2 3 4)
     (fringe (list x x)) ==> (1 2 3 4 1 2 3 4)
     [[file:sicp_scms/2.28.scm][file:~/Dropbox/notes/sicp_scms/2.28.scm]]

- 2.29 :: 二叉活动体必有一个左分支，一个右分支。每个分支是一个具有确定长
     度的杆，上面吊着一个重量或一个子活动体。
     =(define (make-mobile left right) (list left right))=
     =(define (make-branch length structure)(list length structure))=

  1) 定义left-branch 和 right-branch，分别返回活动体的两个分支
  2) 定义branch-length和branch-structure返回一个分支上的成分
  3) 在之前的基础上定义total-weight，返回活动体的总重量
  4) 计算力矩，判断是否平衡
  5) 如果改用下面的定义，你的程序需要修改多少？
     =(define (make-mobile left right) (cons left right))=
     =(define (make-branch length tree) (cons length tree))=

  [[file:sicp_scms/2.29.scm][file:~/Dropbox/notes/sicp_scms/2.29.scm]]

- 2.30 :: 定义 square-tree
     =(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)))=
     输出 (1 (4 (9 16) 25) (36 49)

     [[file:sicp_scms/2.30.scm][file:~/Dropbox/notes/sicp_scms/2.30.scm]]

- 2.31 :: 利用以下方式对2.30进一步抽象
     =(define (square-tree tree) (tree-map square tree))=

     [[file:sicp_scms/2.31.scm][file:~/Dropbox/notes/sicp_scms/2.31.scm]]

- 2.32 :: 可以把集合视作是元素互不相同的表,则一个集合的所有子集表示为
     表的表. 例如(1 2 3) 的子集集合是
     (() (1) (2) (3) (1 2) (1 3) (2 3) (1 2 3))
     给出列举的过程定义
     [[file:sicp_scms/2.32.scm][file:~/Dropbox/notes/sicp_scms/2.32.scm]]

- 2.33 :: 请使用accumulate的方式实现map,append,length这三种基本表操作
     [[file:sicp_scms/2.33.scm::(define%20(length%20items)][2.33.scm]]

- 2.34 :: 采用Horner规则可以对多项式求值
     a(n)*X^n+a(n-1)*X^(n-1)+....a(1)*x+a(0) ==>
     (...(a(n)*x+a(n-1))*x + ... + a(1))x+a0

     定义出过程horner-eval 使可以用 =(horner-eval 2 (list 1 3 0 5 0
     1))= 求值 1+3x+5x^3+x^5 在x等于2时的值
     [[file:sicp_scms/2.34.scm][file:~/Dropbox/notes/sicp_scms/2.34.scm]]

- 2.35 :: 把count-leaves重新定义为累积过程
     [[file:sicp_scms/2.35.scm::(count-leaves%20(list%201%20(list%202%203%20(list%204))%20(list%205%206)))][3.35.scm]]

- 2.36 :: 定义accumulate-n 过程处理序列的序列,将各子序列同位置的元素处
     理,并把结果组合为表
     [[file:sicp_scms/2.36.scm][file:~/Dropbox/notes/sicp_scms/2.36.scm]]

- 2.37 :: 定义向量运算
     (dot-product v w) 返回累积和E(i)(vi*wiv)
     (matrix-*-vector m v) 返回向量i
     (matrix-*-matrix m n) 返回矩阵p
     (transpose m)
     [[file:sicp_scms/2.37.scm][file:~/Dropbox/notes/sicp_scms/2.37.scm]]

- 2.38 :: accumulate也叫fold-right,因为它将序列的第一个元素组合右边所
     有的元素的组合结果上.考虑以下表达式的值
     =(fold-right / 1 (list 1 2 3))=
     =(fold-left / 1 (list 1 2 3))=
     =(fold-right list () (list 1 2 3))=
     =(fold-left list () (list 1 2 3))=
     并且什么情况下,fold-right和fold-left会得出相同的值
     ===>
     (3/2)
     (1/6)
     (1 (2 (3 ())))
     ((() 1) 2) 3)
     f满足结合律

- 3.39 :: 基于fold-right和fold-left定义reverse
     [[file:sicp_scms/2.39.scm][file:~/Dropbox/notes/sicp_scms/2.39.scm]]

- 2.40 :: 定义过程unique-pair，对给定的整数n，输出序对i，j，其中1<＝
     i<j<=n,用这个过程去简化prime-sum-pairs的定义
     [[file:sicp_scms/2.40.scm][file:~/Dropbox/notes/sicp_scms/2.40.scm]]
          
- 2.41 :: 八皇后问题
     [[file:sicp_scms/2.41.scm][file:~/Dropbox/notes/sicp_scms/2.41.scm]]

- 2.42 :: 把上述queens过程中的以下语句对调，耗时相比原来大多少？
     =(map (lambda (new-row)=
     =(lambda (rest-of-queens)=

- 2.54 :: 定义equal?过程，比较两个字符表
     [[file:sicp_scms/2.54.scm][file:~/Dropbox/notes/sicp_scms/2.54.scm]]

- 2.55 :: (car ''abc) 返回quote，为什么？
     ''abc在求值时会被替换成 '(quote abc)的形式

- 2.56 :: 扩充基本求导过程，利用
     exponentiation?,base,exponent,make-exponention等过程，实现以下求
     导规则
     d(u^n)/dx=nu^(n-1)(du/dx)
     [[file:sicp_scms/2.56.scm][file:~/Dropbox/notes/sicp_scms/2.56.scm]]

- 2.57 :: 扩充求导过程，使其能处理任意项的和与乘积，即可以接受以下输入
     =(deriv '(* x y (+ x 3)) 'x)=
     [[file:sicp_scms/2.57.scm][file:~/Dropbox/notes/sicp_scms/257.scm]]

- 2.58 :: 修改过程使其适用于以下表达式
     =(x + 3 * (x + y + 2))=
     [[file:sicp_scms/2.58.scm][file:~/Dropbox/notes/sicp_scms/2.58.scm]]

- 2.59 :: 实现union-set
     #+BEGIN_SRC scheme
       (define (union-set set1 set2)
         (cond ((null? set1) set2)
               ((null? set2) set1)
               (else (let ((left (union-set (cdr set1) set2))
                           (ele (car set1)))
                       (if (element-of-set? ele left)
                           left
                           (adjoin-set ele left))))))
     #+END_SRC

- 2.60 :: 如果不要求无重复，要怎么实现，效率怎么样
     跟列表没区别，除了contain，其他操作都为O(1)

- 2.61 :: 排序的adjoin-set的实现
     另外也可以把x当作单元素的集合,使用union-set的实现
     #+BEGIN_SRC scheme
       (define (adjoin-set x s)
         (cond ((null? s) (list x))
               ((= x (car s)) s)
               ((< x (car s))
                (cons x s))
               (else (cons (car s) (adjoin-set x (cdr s))))))
     #+END_SRC

- 2.62 :: 排序表的union-set的O(n)实现
     #+BEGIN_SRC scheme
       (define (union-set set1 set2)
         (cond ((null? set1) set2)
               ((null? set2) set1)
               (else (let ((s1 (car set1))
                           (s2 (car set2))
                           (l1 (cdr set1))
                           (l2 (cdr set2)))
                       (cond ((equal? s1 s2)
                              (cons s1 (union-set l1 l2)))
                             ((> s1 s2)
                              (cons s2 (union-set set1 l2)))
                             ((< s1 s2)
                              (cons s1 (union-set l1 set2))))))))
     #+END_SRC

- 2.63 :: 下面两个过程都能将树变换为表，有什么区别？
     #+BEGIN_SRC scheme
       (define (tree->list-1 tree)
         (if (null? tree)
             '()
             (append (tree->list-1 (left-branch tree))
                     (cons (entry tree)
                           (tree->list-1 (right-branch tree))))))

       (define (tree-list-2 tree)
         (define (copy-to-list tree result-list)
           (if (null? tree)
               result-list
               (copy-to-list (left-branch tree)
                             (cons (entry tree)
                                   (copy-to-list (right-branch tree)
                                                 result-list))))))
     #+END_SRC
     第一个是递归计算过程，而另一个是迭代计算过程。它们对于同一棵树会
     产生相同的中序列表.
     但它们的复杂度不一样，第一个为O(nlogn),第二个为O(n).
     [[http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/][主定理推断复杂度]]

- 2.64 :: 下面过程将一个有序表变换为一棵平衡二叉树,
     复杂度为n
     #+BEGIN_SRC scheme
       (define (list->tree items)
         (cond ((null? items) '())
               ((= 1 (length items))
                (make-tree (car items) '() '()))
               (else (let ((index (quotient (length items) 2)))
                       (make-tree (car (drop items index))
                                  (list->tree (take items index))
                                  (list->tree (cdr (drop items index))))))))

       (list->tree '(1 2 3 4 5))

       (define (list->tree elements)
         (car (partial-tree elements (length elements))))

       (define (partial-tree elts n)
         (if (= n 0)
             (cons '() elts)
             (let ((left-size (quotient (- n 1) 2)))
               (let ((left-result (partial-tree elts left-size)))
                 (let ((left-tree (car left-result))
                       (non-left-elts (cdr left-result))
                       (right-size (- n (+ left-size 1))))
                   (let ((this-entry (car non-left-elts))
                         (right-result (partial-tree (cdr non-left-elts)
                                                     right-size)))
                     (let ((right-tree (car right-result))
                           (remaining-elts (cdr right-result)))
                       (cons (make-tree this-entry left-tree right-tree)
                             remaining-elts))))))))
     #+END_SRC

- 2.65 :: 给出O(n)的二叉树实现的union-set,interaction-set，操作
     因为其各个操作均为O(n），满足要求。
     #+BEGIN_SRC scheme
       (define (union-tree t1 t2)
         (list->tree (union-set (tree->list t1)
                                (tree->list t2))))
     #+END_SRC

- 2.66 :: 二叉树的element-of-set
     #+BEGIN_SRC scheme
       (define (element-of-set? x s)
         (cond ((null? s) #f)
               ((equal? x (entry s)) #t)
               ((< x (entry s)) (element-of-set? x (left-branch s)))
               (else (element-of-set? x (right-branch s)))))
     #+END_SRC

- 2.68 :: 请定义encode
     #+BEGIN_SRC scheme
       (define (encode message tree)
         (map (lambda (x) (find-bit x tree)) message))

       (define (find-bit ch tree)
         (cond ((leaf? tree) '())
               ((pair? (memq ch (symbols (left-branch tree))))
                (cons '0 (find-bit ch (left-branch tree))))
               ((pair? (memq ch (symbols (right-branch tree))))
                (cons '1 (find-bit ch (right-branch tree))))
               (else (error "tree did not contain ch" ch))))
     #+END_SRC

- 2.69 :: 定义(generate-huffman-tree pairs)
     #+BEGIN_SRC scheme
       (define (generate-huffman-tree pairs)
         (successive-merge (make-leaf-set pairs)))

       (define (successive-merge items)
         (if (null? (cdr items))
             (car items)
             (successive-merge (adjoin-set (make-code-tree (car items)
                                                           (cadr items))
                                           (cddr items)))))
     #+END_SRC

- 2.71 :: 如果一个字符表中的权重为，1 2 4 。。。 2^(n-1).其生成的树是
     怎么样的，权重最大的几位表示，最小的又几位。
     归纳法可知，第n个的权重总大于其前面的字符的权重的总和
     故生成的树总是只偏向一边。最短1位，第n个有n位

- 2.72 :: 当字符表满足2.71时，2.68中的过程查找最大权重和最小的增长率分
     别是多少？
     O(n) ; O(n^2)

- 2.73 :: 对于之前的求导过程，我们也可以认为，这个程序是在执行一种基于
     被求导表达式类型的分派工作，其“类型标志”就是代数运算符，对应的操
     作即为deriv。因此，其过程可以重写为
     #+BEGIN_SRC scheme
       (define (deriv exp var)
         (cond ((number? exp) 0)
               ((variable? exp) (if (same-variable? exp var) 1 0))
               (else ((get 'deriv (operator exp)) (operands exp) var))))

       (define (operator exp) (car exp))
       (define (operands exp) (cdr exp))
     #+END_SRC
  1) 为什么我们无法把number?和 same-variable? 也加入到分派中
  2) 写出对应的和积的求导过程并加入到表格中
  3) 添加新的求导过程，如乘幂
  4) 这里使用操作符作为类型，能不能使用另外一种方式，使得可以在deriv里
     用以下方法调用
     =((get (operator exp) 'deriv) (operands exp) var)=

  5) 取不出”操作数“和”类型“。 数字直接表示为数值，变量表示为符号，这已
     经足够了，并没有标志。
  2/3. [[file:sicp_scms/2.73.scm][file:~/Dropbox/notes/sicp_scms/2.73.scm]]
  1. 替换put参数的顺序即可
     
- 2.74 :: 假定每个部门都有自己的记录，各个部门结构不一样，每个记录以员
     工名为键，一个属性列表为值

  1. 设计通用的get-record过程，使其能用于所有部门的记录
     #+BEGIN_SRC scheme
       (define (get-record name file)
         ((get 'get-record (tag-type file)) name (contents file)))
     #+END_SRC
     
  2. get-salary
  3. find-employee-record
  4. 如何增加新部门

- 2.77 :: 此时直接求值(magnitude z)会报错，因为complex并没有相应的
     magnitude操作。必须要执行语句 (put 'magnitude '(complex)
     magnitude) 才能执行，求值过程。
     #+BEGIN_SRC scheme
       (magnitude z)                                                   ; 这个 magnitude 是最外层的通用操作
       (apply-generic 'magnitude z)
       (map type-tag (list z))                                         ; => '(complex)
       (get 'magnitude '(complex))                                     ; => magnitude  ; 这个 magnitude 是定义于 complex 包中的 magnitude
       (apply magnitude (map contents (list z)))                       ; =>  (apply magnitude '((rectangular 3 . 4)))
       (magnitude '(rectangular 3 . 4))
       (apply-generic 'magnitude '(rectangular 3 . 4))
       (map type-tag (list '(rectangular 3 . 4)))                      ; => '(rectangular)
       (get 'magnitude '(rectangular))                                 ; => magnitude  ; 这个 magnitude 是定义于 rectangular 包中的 magnitude
       (apply magnitude (map contents (list '(rectangular 3 . 4))))    ; => (apply magnitude '((3 . 4)))
       (magnitude '(3 . 4))
       (sqrt (+ (square (real-part '(3 . 4)))
                (square (imag-part '(3 . 4)))))
       5
     #+END_SRC

- 2.78 :: scheme-number使用了自己的类型标志，而实际上，scheme已经有实
     现标志了。symbol? 和number?等就用于确定某个数据对象是否具胡特定的
     类型。请修改type-tag,contents,attach-tag过程，使常规数直接采用
     scheme的形式，而不是表示为('scheme-number z)

     #+BEGIN_SRC scheme
       (define (contents datum)
         (cond ((number? datum)
                datum)
               ((pair? datum)
                (cdr datum))
               (else
                (error "Bad tagged datum -- CONTENT" datum))))
       (define (type-tag datum)
         (cond ((number? datum)
                'scheme-number)
               ((pair? datum)
                (car datum))
               (else
                (error "Bad tagged datum -- TYPE-TAG" datum))))
       (define (attach-tag type-tag contents)
         (if (number? contents)
             contents
             (cons type-tag contents)))
     #+END_SRC

- 2.79 2.80 :: 定义一个通用型equ?判断给定的两个数是否相等,一个通用的谓词
     =zero?检查参数是否为0
     #+BEGIN_SRC scheme
       (define (equ? z1 z2)
         (apply-generic 'equ? z1 z2))
       (define (=zero? x)
         (apply-generic '=zero? x))

       (define (install-scheme-number-package)
         (put 'equ? '(scheme-number scheme-number)
              (lambda (x y) (= x y)))
         (put '=zero? '(scheme-number)
              (lambda (x) (= 0)))
         )

       (define (install-rational-package)
         (put 'equ? '(rational rational)
              (lambda (x y) (and (= (numer x) (numer y))
                                 (= (demon x) (demon y)))))
         (put '=zero? '(rational)
              (lambda (x) (= 0 (numer x))))
         )

       (define (install-complex-package)
         (put 'equ? '(complex complex)
              (lambda (x y) (and (= (real-part x) (real-part y))
                                 (= (imag-part x) (imag-part y)))))
         (put '=zero? '(complex)
              (lambda (x) (= 0 (magnitude x))))
         )
     #+END_SRC

- 2.82 :: 修改apply-generic过程，使其可以处理多个参数下的强制问题。一
     种可能的策略是试着将所有参数都强制到第一个参数的类型，然后试第二
     个，如此类推。但这种策略还不够一般，请给出一个例子。
     [[file:sicp_scms/2.82.scm][file:~/Dropbox/notes/sicp_scms/2.82.scm]]

- 2.83 :: 为符号树设计通用的raise操作.
     #+BEGIN_SRC scheme
       (define (raise x) (apply-generic 'raise x))

       ;; add into scheme-number package 
       (put 'raise '(integer)  
            (lambda (x) (make-rational x 1))) 

       ;; add into rational package 
       (put 'raise '(rational) 
            (lambda (x) (make-real (/ (numer x) (denom x))))) 

       ;; add into real package 
       (put 'raise '(real) 
            (lambda (x) (make-from-real-imag x 0))) 
     #+END_SRC

- 2.84 :: 利用raise操作,修改apply-generic过程,使其可以通过逐层提升的方
     式将参数强制到同样的类型
     #+BEGIN_SRC scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
                 (apply proc (map contents args))
                 (if (= (length args) 2)
                     (let ((a1 (car args))
                           (a2 (cadr args)))
                       (apply apply-generic
                              (append (list op)
                                      (if (eq? (type-tag a1)
                                               (type-tag a2))
                                          (map raise args)
                                          (raise-to-same a1 a2)))))
                     (error "No method for these types"
                            (list op type-tags)))))))

       (define (raise-to-same a1 a2)
         (let ((type1 (type-tag a1))
               (type2 (type-tag a2)))
           (if (eq? type1 type2)
               (list a1 a2)
               (cond ((is-super? a1 a2)
                      (raise-to-same a1 (raise a2)))
                     ((is-super? a2 a1)
                      (raise-to-same (raise a1) a2))
                     (else
                      (error "No raise apply for"
                             (list type1 type2)))))))

       (define (is-super? super sub)
         (memq (type-tag super) (type-inheritance sub)))

       (define (type-inheritance a)
         (let ((type (type-tag a)))
           (if (get 'raise (list type))
               (cons (type-tag a)
                     (type-inheritance (raise a)))
               (list type))))

       ;; ------------------------
       ;; apply-generic with all kind of arg number

       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
                 (apply proc (map contents args))
                 (apply apply-generic
                        (append (list op)
                                (if (all-the-same? type-tags)
                                    (map raise args)
                                    (raise-to-same args))))))))

       (define (all-the-same? items)
         (every (lambda (x) (eq? x (car items)))
                items))

       (define (find-common-type args)
         (list-ref (reverse (type-inheritance (car args)))
                   (- (apply min
                           (map (lambda (x)
                                  (length (type-inheritance x)))
                                args))
                      1)))

       (define (raise-to-same args)
         (let ((type (find-common-type args)))
           (map (lambda (x)
                  (raise-into x type))
                args)))

       (raise-to-same (list (make-complex-from-mag-ang 4 0)
                            (make-scheme-number 4)))

       (define (raise-into obj type)
         (cond ((eq? type (type-tag obj)) obj)
               ((get 'raise (list (type-tag obj)))
                (raise-into (raise obj) type))
               (else (error "cannot raise" (list obj 'into type)))))

       (equ? (make-complex-from-mag-ang 4 0)
             (make-scheme-number 4))
       (real-part (make-scheme-number 4))
     #+END_SRC

- 2.85 :: 设计一个drop过程，使其可以通过下降来”简化“一个数据对象.
     我们可以通过先对一个对象project然后再raise它，看它的值是否跟原来
     一致，从而判断其是否可以下降。
     #+BEGIN_SRC scheme
       (define (apply-generic op . args)
         (let ((type-tags (map type-tag args)))
           (let ((proc (get op type-tags)))
             (if proc
                 (let ((result (apply proc (map contents args))))
                   (if (memq op '(raise)) ; 如果是有意提升，不要drop
                       result
                       (drop result)))
                 (apply apply-generic
                        (append (list op)
                                (if (all-the-same? type-tags)
                                    (map raise args)
                                    (raise-to-same args))))))))
       (define (project x) (apply-generic 'project x))
       (define (drop x)
         (if (and (pair? x) ; 仅当是特殊数据的时候才考虑drop
                  (get 'project (list (type-tag x)))
                  (equ? (raise (project x)) x))
             (drop (project x))
             x))

       (add (make-complex-from-real-imag 4 0)
            (make-rational 2 1))
     #+END_SRC

- 2.86 :: 假如定义复数的实部，虚部，角，幅都是由常规数或有理数或是其他
     我们加入系统中的新类型组成的，我们应该如何修改。注意sine和cosine
     一类计算也要定义成在这些类型上的通用计算
     #+BEGIN_SRC scheme
       (define (sine x) (apply-generic 'sine x)) 
        (define (cosine x) (apply-generic 'cosine x)) 
  
        ;; add into scheme-number package 
        (put 'sine 'scheme-number 
             (lambda (x) (tag (sin x)))) 
        (put 'cosine 'scheme-number 
             (lambda (x) (tag (cos x)))) 
  
        ;; add into rational package 
        (put 'sine 'rational 
             (lambda (x) (tag (sin x)))) 
        (put 'cosine 'rational 
             (lambda (x) (tag (cos x)))) 
  
        ;; To accomodate generic number in the complex package,  
        ;; we should replace operators such as + , * with theirs 
        ;; generic counterparts add, mul. 

     #+END_SRC


- 2.87 :: 请在通用算术包中为多项式安装=zero?,这将使adjoin-term也能对系
          数本身是多项式的多项式使用
          [[file:SICP.org::*%E4%B9%A0%E9%A2%98][2.80]]
          #+BEGIN_SRC scheme
            (define (install-polynomial-package)
              ;; ......
              (put '=zero? 'polynomial
                   (lambda (p)
                     ;;  map a empty-term-list will return '(), every a '() will still return #t
                     (every =zero? (map cdr (term-list p))))) ;; 仅能对parse的term-list使用
              ;; ......
              )

            (define (=zero? x) (apply-generic '=zero? x))
          #+END_SRC

- 2.88 :: 扩充多项式系统,加上多项式的减法
          #+BEGIN_SRC scheme
            (define (install-polynomial-package)
            ;; ......

              (define (sub-poly p1 p2)
                (add-poly p1 (minus p2)))

              (define (minus p)
                (map (lambda (term)
                       (make-term (order term)
                                  (let ((coe (coeff term)))
                                    (if (poly? coe)
                                        (minus coe)
                                        (sub (make-scheme-number 0) coe)))))
                     (term-list p)))

              (define (poly? p)
                (and (pair? p)
                     (equal? 'polynomial
                             (type-tag p))))

              (put 'sub '(polynomial polynomial)
                   (lambda (p1 p2) (tag (sub-poly p1 p2))))
             ;; ......
            )


          #+END_SRC

- 2.89 :: 定义一些过程使其适应稠密的多项式
          #+BEGIN_SRC scheme
            (define (adjoin-term term term-list) 
              (let ((exponent (order term)) 
                    (len (length term-list))) 
                (define (iter-adjoin times terms) 
                  (cond ((=zero? (coeff term)) 
                         terms)) 
                  ((= exponent times) 
                   (cons (coeff term) terms)) 
                  (else (iter-adjoin (+ times 1)  
                                     (cons 0 terms)))) 
                (iter-adjoin len term-list)))

            (define (first-term term-list)
              (cons (- (length term-list) 1)
                    (car term-list)))
          #+END_SRC

- 2.90 :: 模仿复数的两种实现方式,使用两种方式来分别表示稠密和稀疏的多
          项式.
          [[file:sicp_scms/2.90.scm][2.90.scm]]

- 2.91 :: 多项式的除法可以看作是,用被除式的最高次项除以除式的最高次项,
          得到的则是商的每一项,而后用这个结果乘以除式,并从被除式中减去
          这个乘积,剩下的工作就是用减后得到的差作为新的被除式,直到被除
          式的最高次数低于除式的最高次.此时被除式就是余式.
          #+BEGIN_SRC scheme
            (define (div-terms l1 l2)
              (if (empty-termlist? l1)
                  (list (the-empty-termlist) (the-empty-termlist))
                  (let ((t1 (first-term l1))
                        (t2 (first-term l2)))
                    (if (> (order t2) (order t1))
                        (list (the-empty-termlist) l1)
                        (let ((new-c (div (coeff t1) (coeff t2)))
                              (new-o (- (order t1) (order t2))))
                          (let ((rest-of-result
                                 (div-terms (sub-terms l1
                                                       (mul-terms l2
                                                                  (make-parse-terms
                                                                   (make-term new-o new-c))))
                                            l2)
                                 ))
                            (list (adjoin-term (make-term new-o new-c)
                                               (car rest-of-result))
                                  (cdr rest-of-result))))))))
          #+END_SRC




   



     

     

     
* Modularity, Objects, and State
* Metalinguistic Abstraction
* Computing with Register Machines
[[*高阶操作][高阶操作]]
